{
    "contents" : "\n#'##############################################################\n#' stores the data of a learning process on netName with\n#' a certain method, number of samples, id of data base file\n#' arguments:\n#' @param netName name of the net. The results will be related to the\n#'            folder belonging to this net\n#' @param method this flag shows the algorithm producing the results\n#'           (mamp - pc)\n#' @param samples number of samples of the database used for learning\n#'           (this name is used to organize the results into folders)\n#' @param id id of the database. The is will be included in the filename\n#'            including the results\n#' @param results results to store\n#'##############################################################\nstoreNetResults <- function(netName, method, samples, id, results){\n  # checks if the folder where to store the results exist\n  basicPath <- \"./results/\"\n  if (!file.exists(basicPath)){\n    dir.create(basicPath)\n  }\n  \n  # checks if the folder for the net exist\n  path <- paste(basicPath,netName,sep=\"/\")\n  if (!file.exists(path)){\n    dir.create(path)    \n  }\n  basicPath <- path\n  \n  # checks if the folder for the method exist\n  path <- paste(basicPath,method,sep=\"/\")\n  if (!file.exists(path)){\n    dir.create(path)    \n  }\n  basicPath <- path\n  \n  # checks the existence of the folder with the number of samples\n  path <- paste(basicPath,samples,sep=\"/\")\n  if (!file.exists(path)){\n    dir.create(path)    \n  }\n  \n  # write the file\n  fileName <- paste(netName,\"-\",sep=\"\")\n  fileName <- paste(fileName,samples,sep=\"\")\n  fileName <- paste(fileName,\"-\",sep=\"\")\n  fileName <- paste(fileName,id,sep=\"\")\n  fileName <- paste(fileName,\".dat\",sep=\"\")\n  finalPath <- paste(path,fileName,sep=\"/\")\n  write.table(results, file = finalPath, row.names=FALSE, col.names=FALSE, sep=\",\")\n}\n\n#'##############################################################\n#' method to load the results of a certain execution\n#' arguments: \n#' @param netName name of the net of interest\n#' @param method method which produced the results\n#' @param samples number of samples of the database\n#' @param id id of the database\n#' NOTE: this method geneates the results in a similar way as\n#' they appear in the paper\n#'##############################################################\nloadNetResults <- function(netName, method, samples, id){\n  # compone el nombre del path\n  basicPath <- \"./results\"\n  path <- paste(basicPath,netName,sep=\"/\")\n  path <- paste(path,method,sep=\"/\")\n  path <- paste(path,samples,sep=\"/\")\n  path <- paste(path,netName,sep=\"/\")\n  path <- paste(path,samples,sep=\"-\")\n  path <- paste(path,id,sep=\"-\")\n  path <- paste(path,\".dat\",sep=\"\")\n\n  # se lee el archivo\n  data <- as.data.frame(c(0,0,0,0))\n  if (file.exists(path)){\n     data <- read.csv(path,header=FALSE)\n  }\n  return(data)\n}\n\n#'##############################################################\n#' method to load the results of a certain execution\n#' arguments: \n#' @param netName name of the net of interest\n#' @param method method which produced the results\n#' @param samples number of samples of the database\n#' @param repetitions variants for each sample size\n#'##############################################################\nprocessResults <- function(netName, method, samples, repetitions){\n  \n  # se crea la matriz donde se almacenaran al final los resultados\n  resultsMean <- matrix(0,4,length(samples))\n  resultsDev <- matrix(0,4,length(samples))\n  \n  # considera cada posible tamaño de conjunto de datos\n  for(i in 1:length(samples)){\n    size <- samples[i]\n    \n    # se crea matriz de resultados para cada tamaño muestral\n    partialResults <- matrix(0,4,repetitions)\n    \n    for(j in 1:repetitions){\n      # se leen los datos de cada conjunto de datos\n      result <- loadNetResults(netName, method, size, j)\n      \n      # se vuelcan sobre la matriz\n      partialResults[,j] <- result[,1]\n    }\n    \n    cat(\"Partial results............................\\n\")\n    print(partialResults)\n    cat(\"-------------------------------------------\\n\")\n    \n    # now computes mean and deviation for this results\n    for(j in 1:4){\n      vals <- partialResults[j,]\n      \n      # counts all meaningful values (non cero, non NA\n      vals <- vals[!is.na(vals)]\n      \n      # compute mean and deviation\n      resultsMean[j,i] <- mean(vals)\n      resultsDev[j,i] <- sd(vals)\n    }\n  }\n  \n  # return results\n  return(list(mean=resultsMean,dev=resultsDev))\n}\n\n\n#'##############################################################\n#' generate a latex table reading the data pased as third argument\n#' arguments: \n#' @param netName name of the net\n#' @param samples vector of sample sizes\n#' @param results results of the execution to put into the table\n#'##############################################################\ngenerateLatexTableFromData <- function(netName, samples, results){\n  \n  # se crea la matriz donde se almacenaran al final los resultados\n  resultsMean <- matrix(0,8,length(samples))\n  resultsDev <- matrix(0,8,length(samples))\n\n  for(i in 1:length(samples)){\n\n    # compute mean and deviations removing NAs\n    resultsMean[,i] <- apply(results[[i]],1,function(x){\n      x <- x[!is.na(x)]\n      mean(x)\n    })\n  \n    resultsDev[,i] <- apply(results[[i]],1,function(x){\n      x <- x[!is.na(x)]\n      sd(x)\n    })\n  }\n  \n  sink()\n  sink()\n  options(digits=2)\n  traza <- paste(netName,\"-results\",sep=\"\")\n  sink(traza)\n  options(digits=2)\n  \n  # genera la tabla latex con los resultados\n  cat(\"\\\\begin{table}[h!]\\n\")\n  cat(\"\\\\centering\\n\")\n  cat(\"\\\\begin{tabular}{|c|c|c|c|c|c|c|}\\\\hline\")\n  cat(\" size & &\")\n  for(i in 1:length(samples)){\n    cat(samples[i], \" \")\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\hline\\\\hline\\n\")\n  \n  cat(\"\\\\multirow{4}{*}{Our algorithm}\\n\")\n  \n  # recall data\n  cat(\"  & RA & \")\n  \n  # salida de valores de recall para cada tamaño muestral\n  for(i in 1:length(samples)){\n    cat(resultsMean[1,i], \" $\\\\pm$ \", resultsDev[1,i])\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\cline{2-7}\\n\")\n  \n  # precision data\n  cat(\"  & PA & \")\n  \n  # salida de valores de recall para cada tamaño muestral\n  for(i in 1:length(samples)){\n    cat(resultsMean[2,i], \" $\\\\pm$ \", resultsDev[2,i])\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\cline{2-7}\\n\")\n  \n  # recallVS data\n  cat(\"  & RT & \")\n  \n  # salida de valores de recall para cada tamaño muestral\n  for(i in 1:length(samples)){\n    if (is.na(resultsMean[3,i])){\n      resultsMean[3,i] <- 0\n      resultsDev[3,i] <- 0\n    }\n    cat(resultsMean[3,i], \" $\\\\pm$ \", resultsDev[3,i])\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\cline{2-7}\\n\")\n  \n  # prevVS data\n  cat(\"  & PT & \")\n  \n  # salida de valores de recall para cada tamaño muestral\n  for(i in 1:length(samples)){\n    if (is.na(resultsMean[4,i])){\n      resultsMean[4,i] <- 0\n      resultsDev[4,i] <- 0\n    }\n    cat(resultsMean[4,i], \" $\\\\pm$ \", resultsDev[4,i])\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\cline{1-7}\\n\\\\hline\\\\hline\\n\")\n  \n  cat(\"\\\\multirow{4}{*}{Meek's algorithm}\\n\")\n  \n  # recall data\n  cat(\"  & RA & \")\n  \n  # salida de valores de recall para cada tamaño muestral\n  for(i in 1:length(samples)){\n    cat(resultsMean[5,i], \" $\\\\pm$ \", resultsDev[5,i])\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\cline{2-7}\\n\")\n  \n  # precision data\n  cat(\"  & PA & \")\n  \n  # salida de valores de recall para cada tamaño muestral\n  for(i in 1:length(samples)){\n    cat(resultsMean[6,i], \" $\\\\pm$ \", resultsDev[6,i])\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\cline{2-7}\\n\")\n  \n  # recallVS data\n  cat(\"  & RT & \")\n  \n  # salida de valores de recall para cada tamaño muestral\n  for(i in 1:length(samples)){\n    if (is.na(resultsMean[7,i])){\n      resultsMean[7,i] <- 0\n      resultsDev[7,i] <- 0\n    }\n    cat(resultsMean[7,i], \" $\\\\pm$ \", resultsDev[7,i])\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\cline{2-7}\\n\")\n  \n  # prevVS data\n  cat(\"  & PT & \")\n  \n  # salida de valores de recall para cada tamaño muestral\n  for(i in 1:length(samples)){\n    if (is.na(resultsMean[8,i])){\n      resultsMean[8,i] <- 0\n      resultsDev[8,i] <- 0\n    }\n    cat(resultsMean[8,i], \" $\\\\pm$ \", resultsDev[8,i])\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\cline{1-7}\\n\")\n  cat(\"\\\\end{tabular}\\n\")\n  cat(\"\\\\end{table}\\n\")\n  sink()\n  sink()\n  sink()\n}\n\n#'##############################################################\n#' generate a latex table reading the data from the result files\n#' arguments: \n#' @param netName name of the net\n#' @param samples vector of sample sizes\n#' @param repetitions number of databases (variants) to consider\n#'##############################################################\ngenerateLatexTableFromFiles <- function(netName, samples, repetitions){\n  # gets the data from the files and process them. This is done by\n  # the function processResults defined in processResults.R file\n  resultsMampcg <- processResults(netName, \"mampcg\", samples, repetitions)\n  resultsPc <- processResults(netName, \"pc\", samples, repetitions)\n\n  # generate the table\n  sink()\n  sink()\n  options(digits=2)\n  traza <- paste(netName,\"-results2\",sep=\"\")\n  sink(traza)\n  options(digits=2)\n  \n  # genera la tabla latex con los resultados\n  cat(\"\\\\begin{table}[h!]\\n\")\n  cat(\"\\\\centering\\n\")\n  cat(\"\\\\begin{tabular}{|c|c|c|c|c|c|c|}\\\\hline\")\n  cat(\" size &  &\")\n  for(i in 1:length(samples)){\n    cat(samples[i], \" \")\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\hline\\\\hline\\n\")\n  \n  cat(\"\\\\multirow{4}{*}{Our algorithm}\\n\")\n  \n  # recall data\n  cat(\"  & RA & \")\n  \n  # salida de valores de recall para cada tamaño muestral\n  for(i in 1:length(samples)){\n    cat(resultsMampcg$mean[1,i], \" $\\\\pm$ \", resultsMampcg$dev[1,i])\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\cline{2-7}\\n\")\n  \n  # precision data\n  cat(\"  & PA & \")\n  \n  # salida de valores de recall para cada tamaño muestral\n  for(i in 1:length(samples)){\n    cat(resultsMampcg$mean[2,i], \" $\\\\pm$ \", resultsMampcg$dev[2,i])\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\cline{2-7}\\n\")\n  \n  # recallVS data\n  cat(\"  & RT & \")\n  \n  # salida de valores de recall para cada tamaño muestral\n  for(i in 1:length(samples)){\n    cat(resultsMampcg$mean[3,i], \" $\\\\pm$ \", resultsMampcg$dev[3,i])\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\cline{2-7}\\n\")\n  \n  # prevVS data\n  cat(\"  & PT & \")\n  \n  # salida de valores de recall para cada tamaño muestral\n  for(i in 1:length(samples)){\n    cat(resultsMampcg$mean[4,i], \" $\\\\pm$ \", resultsMampcg$dev[4,i])\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\cline{1-7}\\n\\\\hline\\\\hline\\n\")\n  \n  cat(\"\\\\multirow{4}{*}{Meek's algorithm}\\n\")\n  \n  # recall data\n  cat(\"  & RA & \")\n  \n  # salida de valores de recall para cada tamaño muestral\n  for(i in 1:length(samples)){\n    cat(resultsPc$mean[1,i], \" $\\\\pm$ \", resultsPc$dev[1,i])\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\cline{2-7}\\n\")\n  \n  # precision data\n  cat(\"  & PA & \")\n  \n  # salida de valores de recall para cada tamaño muestral\n  for(i in 1:length(samples)){\n    cat(resultsPc$mean[2,i], \" $\\\\pm$ \", resultsPc$dev[2,i])\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\cline{2-7}\\n\")\n  \n  # recallVS data\n  cat(\"  & RT & \")\n  \n  # salida de valores de recall para cada tamaño muestral\n  for(i in 1:length(samples)){\n    cat(resultsPc$mean[3,i], \" $\\\\pm$ \", resultsPc$dev[3,i])\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\cline{2-7}\\n\")\n  \n  # prevVS data\n  cat(\"  & PT & \")\n  \n  # salida de valores de recall para cada tamaño muestral\n  for(i in 1:length(samples)){\n    cat(resultsPc$mean[4,i], \" $\\\\pm$ \", resultsPc$dev[4,i])\n    if (i != length(samples)){\n      cat(\" & \")\n    }\n  }\n  cat(\"\\\\\\\\\\\\cline{1-7}\\n\")\n  cat(\"\\\\end{tabular}\\n\")\n  cat(\"\\\\end{table}\\n\")\n  sink()\n  sink()\n  sink()\n}\n\n# this is an example about the way of retrieving the result of\n# a given execution\n#data <- loadNetResults(\"alarm\",\"pc\",100,1)\n\n",
    "created" : 1445349622417.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "8946026",
    "id" : "9C4ACDF7",
    "lastKnownWriteTime" : 1445352082,
    "path" : "~/desarrollo/jmpenna/aprendizaje/versionComentada/mampcg/R/utilResults.R",
    "project_path" : "R/utilResults.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "type" : "r_source"
}