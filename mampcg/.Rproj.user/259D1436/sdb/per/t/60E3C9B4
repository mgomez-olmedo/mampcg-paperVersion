{
    "contents" : "library(bnlearn)\nlibrary(parallel)\n\n\n#'###################### SECTION 1: auxiliar functions #########################\n\n#'#############################################################\n#' gets a new id for a model analyzing a given folder. If networks\n#' folder contains models artificial1....artificial10 the new model\n#' will be artificial11\n#' arguments:\n#' @param baseFileName reference name\n#' @param folder to analyze\n#' @return new file name\n#'#############################################################\ngetNewFileName <- function(baseFileName, pathNet){\n  # gets all the files matching baseFileName in the path\n  files <- NULL\n  files <- list.files(pathNet, pattern=baseFileName, include.dirs=FALSE)\n  \n  # gets the biggest id\n  maxId <- 0\n  if (length(files) != 0){\n    for(i in 1:length(files)){\n      name <- files[[i]]\n      # removes the extension\n      basename <- strsplit(name,'[.]')[[1]][1]\n      \n      # gets the number\n      number <- as.numeric(substring(basename,nchar(baseFileName)+1, \n                                     nchar(basename)))\n      \n      # checks if needed to update maxId\n      if (maxId < number){\n        maxId <- number\n      }\n    }\n  }\n  \n  # returns the new name\n  name <- paste0(baseFileName,maxId+1)\n}\n\n#'#############################################################\n#' creates a directed edge between two nodes\n#' arguments:\n#' @param errorNode a extreme of the new edge\n#' @param node another extreme of the new edge\n#' @param edges edges defining the model\n#' @param leftDeco deco for left node\n#' @param rightDeco deco for right node\n#' @return new list of edges after the addition\n#'##############################################################\ncreateEdge <- function(errorNode, node, edges, leftDeco, rightDeco){\n  \n  # gets the number of edges\n  nrows <- nrow(edges)\n  \n  # adds one to nrow\n  nrows <- nrows+1\n  \n  # adds the edge\n  edges[nrows,] <- c(errorNode, node, leftDeco, rightDeco)\n  \n  # return edges\n  edges\n}\n\n#'##############################################################\n#' deletes a row from the data frame\n#' arguments:\n#' @param from first node\n#' @param to second node\n#' @param edges edges defining the model\n#' @return new list of edges after removal\n#'##############################################################\ndeleteEdge <- function(from, to, edges){\n  \n  # removes the edge\n  index <- which((edges$from == from & edges$to == to) |\n                   (edges$to == from & edges$from == to))\n  edges <- edges[-index, ]\n  \n  # changes row names\n  rownames(edges) <- 1:nrow(edges)\n  \n  # return edges\n  return(edges)\n}\n\n#'#############################################################\n#' deletes an edge selected at random between those belonging\n#' to a given path\n#' arguments:\n#' @param path path to consider\n#' @param edges set of edges to analyze\n#' @return new list of edges after deletion\n#'#############################################################\ndeleteEdgeAtRandom <- function(path, edges){\n  # removes the cycle deleting an edge\n  pathLength <- length(path)\n  \n  # selects a random number between 1 and pathLength\n  index <- sample(1:pathLength,1)\n  \n  # deletes the edge\n  from <- path[[index]]\n  if (index < pathLength){\n    to <- path[[index+1]]\n  }\n  else{\n    to <- path[[1]]\n  }\n  \n  # detele the edge\n  edges <- deleteEdge(from, to, edges)\n}\n\n#'#############################################################\n#' checks if there is an undirected edge between two nodes\n#' arguments:\n#' @param nodeA first node\n#' @param nodeB second node\n#' @param edges edges to consider\n#' @return flag boolean value\n#'#############################################################\ncheckUndirectedEdge <- function(nodeA, nodeB, edges){\n  flag <- FALSE\n  \n  # gets undirected edges for both nodes\n  undirectedEdges <- edges[((edges$from == nodeA & edges$to == nodeB &\n                               edges$left == \"none\" & edges$right == \"none\") | \n                              (edges$from == nodeB & edges$to == nodeA &\n                                 edges$left == \"none\" & edges$right == \"none\")),]\n  \n  if (!is.null(undirectedEdges) & nrow(undirectedEdges) != 0){\n    flag <- TRUE\n  }\n  \n  # return flag\n  return(flag)\n}\n\n#'##############################################################\n#' gets undirected edges for a given node\n#' arguments:\n#' @param node node to consider\n#' @param edges edges where to look for\n#' @return list of edges containing node\n#'##############################################################\ngetUndirectedEdges <- function(node, edges){\n  \n  # gets undirected edges for node\n  edgesForNode <- edges[((edges$from == node | edges$to == node) &\n                           (edges$left == \"none\" & edges$right == \"none\")),]\n}\n\n#'#############################################################\n#' get the nodes involved in a pair of edges, being node\n#' the common node between them\n#' arguments:\n#' @param node common node between the edges\n#' @param edge1 first edge\n#' @param edge2 second edge\n#' @return a list with nodes involved in both edges A - B - C\n#'#############################################################\ngetNodesInEdges <- function(node, edge1, edge2){\n  # sets nodeB\n  nodeB <- node\n  \n  # get nodes A and C\n  nodeA <- getOppositeNode(node, edge1)\n  nodeC <- getOppositeNode(node, edge2)\n  \n  # return a list with these nodes\n  return(list(A=nodeA, B=nodeB, C=nodeC))\n}\n\n#'##############################################################\n#' get the opposite node to the one passed as first argument in the\n#' edge passed as second argument\n# arguments:\n#' @param node reference node\n#' @param edge edge to consider\n#' @return node\n#'##############################################################\ngetOppositeNode <- function(node, edge){\n  other <- edge$from\n  \n  if (node == edge$from){\n    other <- edge$to\n  }\n  \n  # return node\n  return(other)\n}\n\n#'##############################################################\n#' get the spouses for a given node\n#' arguments: \n#' @param node reference node\n#' @param edges edges to analyze\n#' @return list of nodes (spouses)\n#'##############################################################\ngetSpousesForNode <- function(node, edges){\n  # gets edges for node and with arraw-arrow as decoration\n  edgesForNode <- edges[((edges$from == node | edges$to == node) & \n                           edges$left == \"arrow\" & edges$right == \"arrow\"), ]\n  \n  # consider every edge and insert the other node to spouses list\n  spouses <- list()\n  if (!is.null(edgesForNode) & nrow(edgesForNode) != 0){\n    for(i in 1:nrow(edgesForNode)){\n      edge <- edgesForNode[i,]\n      \n      # gets the other node\n      spouses <- c(getOppositeNode(node, edge), spouses)\n    }\n  }\n  \n  # remove repetitions\n  spouses <- unique(spouses)\n  \n  # return spouses\n  return(spouses)\n}\n\n#'##############################################################\n#' get spouses for every node\n#' arguments:\n#' @param edges edges to consider\n#' @return list of spouses for each node\n#'##############################################################\ngetSpouses <- function(edges){\n  # gets all the nodes\n  nodes <- unique(c(unique(edges$from), unique(edges$to)))\n  \n  # apply method for computing spouses for a given variable\n  spouses <- lapply(nodes, getSpousesForNode, edges)\n}\n\n#'##############################################################\n#' gets the neighnbours of node\n#' arguments:\n#' @param node node of reference\n#' @param edges edges to analyze\n#' @return list of neighbours\n#'##############################################################\ngetNeighbours <- function(node, edges){\n  # initializes neighbours\n  neighbours <- list()\n  \n  # get the edges related to node\n  edgesForNode <- edges[(edges$from == node | edges$to == node), ]\n  \n  # gets all the nodes in edges and removes node\n  if (!is.null(edgesForNode) & nrow(edgesForNode) != 0){\n    for(i in 1:nrow(edgesForNode)){\n      neighbours <- c(getOppositeNode(node, edgesForNode[i,]), neighbours)\n    }\n  }\n  \n  # return neighbours\n  return(neighbours)\n}\n\n#'##############################################################\n#' gets the neighnbours of node but taking into account the direction.\n#' if A -> B then B is neighbour of A, but A is not neighbour of B\n#' arguments:\n#' @param node reference node\n#' @param edges edges to analyze\n#' @return list of neighbours\n#'##############################################################\ngetNeighboursWithDirections <- function(node, edges){\n  \n  # initializes neighbours\n  neighbours <- list()\n  \n  # get the edges related to node\n  edgesForNode <- edges[(edges$from == node | edges$to == node), ]\n  \n  # exclude edges with arrow in node side\n  edgesForNode <- edgesForNode[!(((edgesForNode$to == node) & (edgesForNode$right == \"arrow\") &\n                                    (edgesForNode$left == \"none\")) |\n                                   ((edgesForNode$from == node) & (edgesForNode$left == \"arrow\") & \n                                      (edgesForNode$right == \"none\"))),]\n  \n  # gets all the nodes in edges and removes node\n  if (!is.null(edgesForNode) & nrow(edgesForNode) != 0){\n    for(i in 1:nrow(edgesForNode)){\n      neighbours <- c(getOppositeNode(node, edgesForNode[i,]), neighbours)\n    }\n  }\n  \n  # return neighbours\n  return(neighbours)\n}\n\n#'##############################################################\n#' gets the neighnbours of node but taking into accounto only\n#' undirected edges\n#' arguments:\n#' @param node reference node\n#' @param edges edges to analyze\n#' @return list of neighbours\n#'##############################################################\ngetNeighboursWithUndirectedEdges <- function(node, edges){\n  \n  # initializes neighbours\n  neighbours <- list()\n  \n  # get the edges related to node\n  edgesForNode <- getUndirectedEdges(node, edges)\n  \n  # gets all the nodes in edges and removes node\n  if (!is.null(edgesForNode) & nrow(edgesForNode) != 0){\n    for(i in 1:nrow(edgesForNode)){\n      neighbours <- c(getOppositeNode(node, edgesForNode[i,]), neighbours)\n    }\n  }\n  \n  # return neighbours\n  return(neighbours)\n}\n\n#'##############################################################\n#' method for getting the path between two nodes\n#' arguments:\n#' @param from start node\n#' @param to destination node\n#' @param visited flag of boolean values to control visited nodes\n#' @param edges edges to analyze\n#' @param neighboursFunction function to use for neighbours detection\n#' @return list with three entries: boolean flag, list of visited\n#'         nodes and list of non visited edges\n#'##############################################################\ngetPath <- function(from, to=from, visited, edges, neighboursFunction){\n  \n  # inializes the result\n  result <- list(flag=FALSE, path=visited, edges=edges)\n  \n  # base case: if to belongs to visited, return true\n  if (any(visited == to)){\n    result$flag <- TRUE\n  }\n  else{\n    # inductive case: get neigbours of from\n    neighbours <- neighboursFunction(from, edges)\n    \n    # gets the list of nodes to visit    \n    toVisit <- setdiff(neighbours, visited)\n    \n    # consider every node to visit\n    if(length(toVisit) != 0){\n      for(i in 1:length(toVisit)){\n        # sort nodes in lexicographical order\n        toVisit <- sort(unlist(toVisit))\n        \n        # select the node\n        nodeToVisit <- toVisit[i]\n        \n        # removes the edge between nodeToVisit and from\n        edges <- deleteEdge(from, nodeToVisit, edges)\n        \n        # makes a recursive call\n        result <- getPath(nodeToVisit, to, c(nodeToVisit, visited), edges, neighboursFunction)\n        \n        # if result is true, breaks the loop because the path\n        # was found\n        if (result$flag == TRUE){\n          break\n        }\n      }\n    }\n  }\n  \n  # return result\n  return(result)\n}\n\n#'####################### SECTION 2: MAMP functions #########################\n\n#'##############################################################\n#' check condition1 for MAMPCG\n#' arguments: \n#' @param edges set of edges of the model\n#' @return list with: boolean flag (true if the list of edges had\n#'        to be changed) and list of resultant edges\n#'##############################################################\ncheckCondition1 <- function(edges){\n  changed <- FALSE\n  continue <- TRUE\n  \n  while(continue){\n    \n    # get edges none - arrow\n    candidateEdges <- edges[((edges$left == \"none\" & edges$right == \"arrow\") |\n                               (edges$left == \"arrow\" & edges$right == \"none\")), ]\n    \n    # change continue value\n    continue <- FALSE\n    \n    # checks the paths for every node\n    if (nrow(candidateEdges) != 0){\n      for(i in 1:nrow(candidateEdges)){\n        # gets the edge\n        edge <- candidateEdges[i,]\n        \n        # gets node from and to\n        if (edge$left == \"none\"){\n          nodeFrom <- edge$from\n          nodeTo <- edge$to\n        }\n        else{\n          nodeFrom <- edge$to\n          nodeTo <- edge$from\n        }\n        \n        result <- getPath(nodeTo, nodeFrom, list(nodeTo), edges, getNeighboursWithDirections)\n        \n        # if there is a path and the first edge is none - arrow\n        # the condition 1 must be applied\n        if (result$flag == TRUE){\n          \n          # removes an edge randomly selected\n          edges <- deleteEdgeAtRandom(result$path, edges)\n          \n          # repeats the loop\n          continue <- TRUE\n          \n          # sets changed to TRUE\n          changed <- TRUE\n          \n          # breaks the for\n          break\n        }\n      }\n    }\n  }\n  return(list(changed=changed, edges=edges))\n}\n\n#'##############################################################\n#' check condition2 for MAMPCG\n#' arguments:\n#' @param edges edges defining the model\n#' @return list with: boolean flag (true if the list of edges had\n#'        to be changed) and list of resultant edges\n#'##############################################################\ncheckCondition2 <- function(edges){\n  continue <- TRUE\n  changed <- FALSE\n  \n  # detection loop\n  while(continue){\n    # get edges arrow - arrow\n    candidateEdges <- edges[(edges$left == \"arrow\" & edges$right == \"arrow\"), ]\n    \n    # change continue value\n    continue <- FALSE\n    \n    # checks the paths for every node\n    if (nrow(candidateEdges) != 0){\n      for(i in 1:nrow(candidateEdges)){\n        # gets the edge\n        edge <- candidateEdges[i,]\n        \n        # gets node from and to\n        nodeFrom <- edge$from\n        nodeTo <- edge$to\n        \n        # check if there is a path from nodeFrom to nodeTo with undirected edges\n        result <- getPath(nodeTo, nodeFrom, list(nodeTo), edges, getNeighboursWithUndirectedEdges)\n        \n        # if there is a path and the first edge is none - arrow\n        # the condition 1 must be applied\n        if (result$flag == TRUE){\n          \n          # removes an edge randomly selected\n          edges <- deleteEdgeAtRandom(result$path, edges)\n          \n          # repeats the loop\n          continue <- TRUE\n          \n          # sets changed to TRUE\n          changed <- TRUE\n          \n          # breaks the for\n          break\n        }\n      }\n    }\n  }\n  return(list(changed=changed, edges=edges))\n}\n\n#'##############################################################\n#' check condition3 for MAMPCG\n#' arguments:\n#' @param edges edges defining the model\n#' @return list with: boolean flag (true if the list of edges had\n#'        to be changed) and list of resultant edges\n#'##############################################################\ncheckCondition3 <- function(edges){\n  changed <- FALSE\n  continue <- TRUE\n  \n  # check loop\n  while(continue){\n    # sets continue to false\n    continue <- FALSE\n    \n    # gets nodes\n    nodes <- unique(c(edges$from, edges$to))\n    \n    # makes continue FALSE. Only with a change on the edges\n    # this flag will be changed to TRUE\n    continue <- FALSE \n    \n    # considers every node\n    for(i in 1:length(nodes)){\n      node <- nodes[i]\n      \n      # gets undirected edges\n      edgesForNode <- getUndirectedEdges(node, edges)\n      \n      # work only if there are at leas two edges\n      if (!is.null(edgesForNode) & nrow(edgesForNode) >= 2){\n        # considers every pair\n        for(j in 1:(nrow(edgesForNode)-1)){\n          for(k in (j+1):nrow(edgesForNode)){\n            edge1 <- edgesForNode[j,]\n            edge2 <- edgesForNode[k,]\n            \n            # gets the nodes involved in these edges: A - B - C\n            nodesInEdges <- getNodesInEdges(node, edge1, edge2)\n            \n            # gets B node spouses\n            bSpouses <- getSpousesForNode(node, edges)\n            \n            # if this set is not empty, then there must be an\n            # endge between A and C\n            if(!is.null(bSpouses) & length(bSpouses) != 0){\n              # check the link between A and C\n              flag <- checkUndirectedEdge(nodesInEdges$A, nodesInEdges$C, edges)\n              \n              # if flag is false, then adds an edge between A and C\n              if (flag == FALSE){\n                edges[(nrow(edges)+1),] <- c(from=nodesInEdges$A,to=nodesInEdges$C,\n                                             left=\"none\",right=\"none\")\n                \n                # sets continue to TRUE\n                continue <- TRUE\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  # return edges\n  return(list(changed=changed, edges=edges))\n}\n\n#'##############################################################\n#' check if the graph is a MAMPCG\n#' arguments:\n#' @param edges edges defining the model\n#' @return list of edges required for a valid MAMPCG model\n#'##############################################################\ncheckMAMPCG <- function(edges){\n  \n  # initializes flag to TRUE\n  flag <- TRUE\n  \n  # while flag is TRUE\n  while(flag){\n    # check condition1\n    res1 <- checkCondition1(edges)\n    edges <- res1$edges\n    \n    # check condition2\n    res2 <- checkCondition2(edges)\n    edges <- res2$edges\n    \n    # check condition3    \n    res3 <- checkCondition3(edges)\n    edges <- res3$edges\n    \n    # compose the final result\n    if (res1$changed == FALSE & res2$changed == FALSE & res3$changed == FALSE){\n      flag=FALSE\n    }\n  }\n  \n  # return the set of edges\n  return(edges)\n}\n\n#'##############################################################\n#' generates a random graph with a certain probability for directed\n#' undirected and bidirected graphs\n#' arguments:\n#' @param numberNodes number of nodes to consider\n#' @param probDirected probability for directed edges\n#' @param probUndirected probability for undirected edges\n#' @param probBidirected probability for bidirected edges\n#' @return list of resultant edges\n#'##############################################################\ngenerateRandomGraph <- function(numberNodes, probDirected, probUndirected, \n                                probBidirected){\n  \n  # generates a random graph\n  rnet <- bnlearn::random.graph(LETTERS[1:numberNodes],method=\"ic-dag\",\n                                max.in.degree=2)\n  \n  # now gets the arcs\n  rnetArcs <- bnlearn::arcs(rnet)\n  \n  # probability vector: probs for directed, undirected, bidirected\n  probs <- c(probDirected, probUndirected, probBidirected)\n  aprobs <- cumsum(probs)\n  \n  # generates a data frame with the required structure for edges\n  edges <- data.frame(from=character(), to=character(), \n                      left=character(), right=character(), \n                      stringsAsFactors=FALSE)\n  \n  # considers every arc\n  for(i in 1:nrow(rnetArcs)){\n    # selects the edge\n    arc <- rnetArcs[i,]\n    \n    # generates a random number\n    rnumber <- runif(1)\n    \n    # gets the type according to rnumber\n    type <- min(which(aprobs > rnumber))\n    \n    if (type == 1){\n      # it is directed and nothing to do. Just insert the\n      # edge\n      edges[i,] <- c(arc[\"from\"], arc[\"to\"], \"none\",\"arrow\")\n    }\n    else{\n      if (type == 2){\n        # it is undirected\n        edges[i,] <- c(arc[\"from\"], arc[\"to\"], \"none\",\"none\")\n      }\n      else{\n        # bidirected\n        edges[i,] <- c(arc[\"from\"], arc[\"to\"], \"arrow\",\"arrow\")\n      }\n    }\n  }\n  \n  # return edges\n  return(edges)\n}\n\n#'##############################################################\n#' method for generating a MAMPCG model\n#' arguments:\n#' @param numberNodes number of nodes\n#' @param probs probs to use for the generation of directed, undirected\n#'          and bidirected\n#' @return list of edges defining the model\n#'##############################################################\ngenerateRandomMAMPCG <- function(numberNodes, probs){\n  # generate the basic initial structure\n  edges <- generateRandomGraph(numberNodes, probs[1], probs[2], probs[3])\n  \n  # checks the conditions\n  edges <- checkMAMPCG(edges)\n}\n\n#'############### SECTION 3: functions for databases generation ################\n\n#'##############################################################\n#' method for transforming a set of edges in order to construct a\n#' bayesian network\n#' arguments:\n#' @param edges edges defining the model\n#' @return list with two entries: edges of the resultant BN and\n#'         inmoralities produced by the conversion\n#'##############################################################\ntransformToBayesianNetwork <- function(edges){\n  # gets all the nodes\n  nodes <- unique(c(edges$from,edges$to))\n  \n  # paste error prefix to every node\n  rnodes <- sapply(nodes,function(node){\n    rnode <- paste0(\"error\",node)\n  })\n  \n  # include an directed edge for errori to i\n  for(i in 1:length(nodes)){\n    # creates a new edge\n    edges <- createEdge(rnodes[i],nodes[i],edges,\"none\",\"arrow\")\n  } \n  \n  # selects undirected edges\n  undirected <- edges[(edges$left == \"none\" & edges$right == \"none\"),]\n  \n  # initializes inmoralities to empty list\n  inmoralities <- list()\n  \n  # remove the edge and add new edges between errorFrom and errorTo\n  if (nrow(undirected) != 0){\n    for(i in 1:nrow(undirected)){\n      from <- undirected[i,]$from\n      to <- undirected[i,]$to\n      \n      # removes the edge\n      edges <- deleteEdge(from, to, edges)\n      \n      # add edges from error nodes to a new error node\n      errorFrom <- paste0(\"error\",from)\n      errorTo <- paste0(\"error\",to)\n      error <- paste0(\"error\",from)\n      error <- paste0(error,to)\n      edges <- createEdge(errorFrom, error, edges,\"none\",\"arrow\")\n      edges <- createEdge(errorTo, error, edges, \"none\", \"arrow\")\n      \n      # stores error into inmoralities list\n      inmoralities <- unique(c(error, inmoralities))\n    }\n  }\n  \n  # selected bidirected edges\n  bidirected <- edges[(edges$left == \"arrow\" & edges$right == \"arrow\"),]\n  \n  # for every bdirected node introduces links from common error\n  # to error nodes\n  if (nrow(bidirected) != 0){\n    for(i in 1:nrow(bidirected)){\n      from <- bidirected[i,]$from\n      to <- bidirected[i,]$to\n      \n      # removes the edge\n      edges <- deleteEdge(from, to, edges)\n      \n      # add edges from error to from and to\n      error <- paste0(\"error\",from)\n      error <- paste0(error,to)\n      edges <- createEdge(error, from, edges, \"none\", \"arrow\")\n      edges <- createEdge(error, to, edges, \"none\", \"arrow\")\n    }\n  }\n  \n  # return edges and inmoralities\n  return(list(edges=edges, inmoralities=inmoralities))\n}\n\n#'##############################################################\n#' creates a Bnlearn net for helping the generation of distributions\n#' arguments:\n#' @param edges edges defining the model\n#' @param check flag to show if the existance the cycles will be considered\n#' @return resultant bnet\n#'##############################################################\ncreateBnlearnNet <- function(edges, check){\n  # creates an empty graph with the variables\n  nodes <- unique(c(edges$from, edges$to))\n  \n  # creates a bnet \n  bnet <- bnlearn::empty.graph(nodes)\n  \n  # now adds all the edges\n  for(i in 1:nrow(edges)){\n    edge <- edges[i,]\n    #adds the arc\n    bnet <- bnlearn::set.arc(bnet,from=edge$from,to=edge$to, check.cycles=check, \n                              debug=FALSE)\n  }\n  \n  # return bnet\n  return(bnet)\n}\n\n#'##############################################################\n#' method for generating distributions for root nodes\n#' arguments:\n#' @param net net to be considered for databses generation\n#' @return list of distributions for root nodes\n#'##############################################################\ngenerateDistributionForRootNodes <- function(net){\n  # gets all the nodes without parents\n  nodes <- bnlearn::nodes(net)\n  \n  # gets all the parents\n  parentsOfNodes <- sapply(nodes,function(node){\n    bnlearn::parents(net,node)\n  })\n  \n  # initializes the list of distributions\n  distributions <- list()\n  \n  # considers every node\n  for (i in 1:length(nodes)){\n    # gets node\n    node <- nodes[i]\n    \n    # gets parents\n    nodeParents <- parentsOfNodes[[i]]\n    \n    # check if there are no parents\n    if (identical(nodeParents, character(0))){\n      # gets a ramdom value between 1 and 2\n      deviation <- runif(1)+1\n      \n      # sets the distribution\n      distribution <- list(coef = c(\"(Intercept)\" = 0), sd = deviation)\n      \n      # add the distribution to distributions\n      distributions[[node]] <- distribution\n    }\n  }\n  \n  # return distributions\n  distributions\n}\n\n#'##############################################################\n#' method for generating distributions for non-root nodes\n#' arguments:\n#' @param net net to be considered for databses generation\n#' @return list of distributions for non root nodes\n#'##############################################################\ngenerateDistributionForNonRootNodes <- function(net){\n  # gets all the nodes without parents\n  nodes <- bnlearn::nodes(net)\n  \n  # gets all the parents\n  parentsOfNodes <- sapply(nodes,function(node){\n    bnlearn::parents(net,node)\n  })\n  \n  # initializes the list of distributions\n  distributions <- list()\n  \n  # considers every node\n  for (i in 1:length(nodes)){\n    # gets node\n    node <- nodes[i]\n    \n    # gets parents\n    nodeParents <- parentsOfNodes[[i]]\n    \n    # node will have average = 0 and deviation = 0\n    coefs <- c(\"(Intercept)\"=0)\n    \n    # check if there are no parents\n    if (!identical(nodeParents, character(0))){\n      \n      # considers every parent\n      for(j in 1: length(nodeParents)){\n        # generate the factor\n        parent <- nodeParents[j]\n        \n        # checks if it is a error node\n        if(length(grep(\"error\",parent)) > 0){\n          factor <- 1\n        }\n        else{\n          factor <- runif(1)+1\n        }\n        \n        # adds the factor to coefs\n        coefs[parent] <- factor\n      }\n      \n      # sets the distribution\n      distribution <- list(coef=coefs, sd = 0)\n      \n      # add the distribution to distributions\n      distributions[[node]] <- distribution\n    }\n  }\n  \n  # return distributions\n  distributions\n}\n\n#'##############################################################\n#' method for setting the parameters to the net\n#' arguments: \n#' @param net net to consider\n#' @param params parameters to set\n#' @param resultant bnet.fit (with parameters)\n#'##############################################################\nsetParameters <- function(net, params){\n  # composes all the distributions\n  net <- bnlearn::custom.fit(net, params)\n}\n\n#'##############################################################\n#' method for remmoving from the complete data set the evidential\n#' variables\n#' arguments:\n#' @param sample sample to filter removing evidence variables\n#' @param evidenceVariables variables to remove from sample\n#' @return dataframe with samples after removing columns for\n#'         evidential variables\n#'##############################################################\nremoveEvidentialVariables <- function(sample, evidenceVariables){\n  # gets the complete list of nodes\n  nodes <- names(sample)\n  \n  # removes evidence variables\n  sample[ , -which(names(sample) %in% evidenceVariables)]\n}\n\n#'##############################################################\n#' method for generating the complete dataset with the required sample\n#' size\n#' arguments: \n#' @param model model to sample from\n#' @param sampleSize size of the sample to generate\n#' @param threshold value to consider for evidence expressions\n#' @param cl cluster to use (if possible to use several cores)\n#' @return dataframe with samples\n#'##############################################################\ngenerateSample <- function(model, sampleSize, threshold, cl){\n  # forms a expression where nodes in inmoralities are set to a value \n  # >= -threshold and <= threshold\n  # forms the expressions for evidence: strB for >= expression\n  # strL for <= expression and strC for the concatenation of both of them\n  strB=paste(\"(\",model$inmoralities, \" >= \", -threshold, \")\", sep=\"\", collapse = \" & \")\n  strL=paste(\"(\",model$inmoralities, \" <= \", threshold, \")\", sep=\"\", collapse = \" & \")\n  strC=paste(strB, strL, sep=\" & \")\n  cat(\"Evidence expression: \", strC, \"\\n\")\n\n  # export strC to cluster nodes\n  environment(strC) <- .GlobalEnv\n  parallel::clusterExport(cl, \"strC\", envir=environment())\n  \n  # loop for getting the samples\n  data <- NULL\n  nSamples <- 0\n  \n  while(nSamples < sampleSize){\n    # generate data. Perhaps the parameters must be changed for a faster generation\n    # depending on the concrete model\n    dataf <- bnlearn::cpdist(model$bnetSampling, nodes=bnlearn::nodes(model$bnet), \n                             evidence=eval(parse(text=strC)), method=\"ls\", \n                             debug=FALSE, cluster=cl, batch=50000, \n                             n=sampleSize*30000)\n \n    # updates the number of samples\n    nSamples <- nSamples+nrow(dataf)\n    cat(\"..\",nSamples,\"..\")\n    \n    # join all the samples into data\n    if(is.null(data)){\n      data <- dataf\n    }\n    else{\n      data <- rbind(data,dataf)\n    }\n  }\n\n  # now remove all the variables containing error in their names\n  data <- data[,-grep(\"error\", colnames(data))]\n  \n  # remove extra samples\n  data <- data[(1:sampleSize),]\n  \n  # return data\n  return(data)\n}\n\n#'##############################################################\n#' function for storing the data set to a file \n#' arguments:\n#' @param sample: sample to store\n#' @param id id of the database\n#' @param numberSamples number of samples\n#' @param path path where databases must be stored\n#' @param filename filename to use\n#' @return \n#'##############################################################\nstoreDatabase <- function(sample, id, numberSamples, path, filename){\n\n  # compose the complete path to the file and creates the folder\n  # if needed\n  cpath <- paste0(path,filename)\n  if (!file.exists(cpath)){\n    dir.create(file.path(path,filename))\n  }\n\n  # gets the number of samples and concatenates with cpath\n  if (!file.exists(paste(cpath,numberSamples,sep=\"/\"))){\n    dir.create(file.path(cpath,numberSamples))\n  }\n  cpath <- paste(cpath,numberSamples,sep=\"/\")\n\n  # now composes the name of the file\n  filename <- paste(filename,numberSamples,sep=\"-\")\n  filename <- paste(filename,id,sep=\"-\")\n  filename <- paste0(filename,\".db\")\n  filename <- paste(cpath,filename,sep=\"/\")\n\n  # writes the table\n  write.table(sample,file=filename,col.names=TRUE, row.names=FALSE,sep=\",\")\n}\n\n#'##############################################################\n#' method for storing the complete model: edges, bnet with\n#' distributions and inmoralities\n#' arguments:\n#' @param model list containg all the information\n#' @param folder where to store the model\n#'##############################################################\nstoreModel <- function(model, folder){\n  \n  # compose the folder with model name\n  pathName <- paste0(folder,model$name)\n  pathName <- paste0(pathName,\".mampcg\")\n  \n  # uses the name of the model for storing info into an R file\n  # (name, edges, bnet and inmoralities)\n  saveRDS(model, pathName)\n}\n\n#'##############################################################\n#' method for retrieving the complete model: edges, bnet with\n#' distributions and inmoralities\n#' arguments:\n#' @param name of the model\n#' @param folder where to look for the model\n#' @return model\n#'##############################################################\nretrieveModel <- function(modelname, folder){\n  \n  # compose the folder with model name\n  pathName <- paste0(folder,modelname)\n  pathName <- paste0(pathName,\".mampcg\")\n  \n  # uses the name of the model for storing info into an R file\n  # (name, edges, bnet and inmoralities)\n  model <- readRDS(pathName)\n}\n\n\n#'##############################################################\n#' prepare a MAMPCG model for sampling data from it\n#' arguments:\n#' @param edges\n#' @param basename base name for the models\n#' @param folder to analyze in order to assign an unique identifier\n#' @return list with four entries: name, edges, bnet and inmoralities\n#'##############################################################\nprepareMAMPCGForSampling <- function(edges, basename, folder){\n  \n  # gets a unique name for this model\n  name <- getNewFileName(basename, folder)\n  \n  # creates a BN from edges, without checking edges\n  baseBnet <- createBnlearnNet(edges, check=FALSE)\n  \n  # transform into BN\n  result <- transformToBayesianNetwork(edges)\n  \n  # create a bnlearn net for preparing parameters generaration\n  bnet <- createBnlearnNet(result$edges, TRUE)\n  \n  # compute distributions for root nodes\n  distributionsRootNodes <- generateDistributionForRootNodes(bnet)\n  \n  # compute distributions for non root nodes\n  distributionsNonRootNodes <- generateDistributionForNonRootNodes(bnet)\n  \n  # compose the complete set of distributions\n  distributions <- c(distributionsRootNodes, distributionsNonRootNodes)\n  \n  # now sets all the distributions to the net\n  bnet <- setParameters(bnet, distributions)\n  \n  # finally return the name, edges, net and the set of inmoralities\n  return(list(name=name, edges=edges, bnet=baseBnet, bnetSampling=bnet, inmoralities=result$inmoralities))\n}\n\n#'##############################################################\n# method for generating data sets given a model\n# arguments:\n#' @param model model to use for generation\n#' @param variants number of variants to generate\n#' @param sampleSizes vector of sample sizes\n#' @param threshold for evidence expressions\n#' @param pathDb path where databases will be generated\n#' @param cluster cluster to use several cores\n#'##############################################################\ngenerateDatabases <- function(model, variants, sampleSizes, threshold, pathDb, cluster){\n\n  # considers every sample size\n  for(ss in 1:length(sampleSizes)){\n    \n    # generates the variants\n    for(v in 1:variants){\n      # use this net for generating a sample\n      data <- generateSample(model, sampleSizes[ss], threshold, cluster)\n      \n      # finally store the data\n      storeDatabase(data, v, sampleSizes[ss], pathDb, model$name)\n    }\n  }\n}\n\n",
    "created" : 1445342124994.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2957621203",
    "id" : "60E3C9B4",
    "lastKnownWriteTime" : 1445348441,
    "path" : "~/desarrollo/jmpenna/aprendizaje/versionComentada/mampcg/R/generateMAMPCG.R",
    "project_path" : "R/generateMAMPCG.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : true,
    "type" : "r_source"
}