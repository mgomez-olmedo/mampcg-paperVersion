{
    "contents" : "\nlibrary(bnlearn)\nlibrary(data.table)\nlibrary(R6)\n\n#'##############################################################\n#' class definition. Data members\n#' moral: flag to define the way of considering v-structures\n#' net: true Bayesian network\n#' debug: flag for printing debug information\n#' data: dataset used for learning\n#' alpha: alpha for statistical tests of independence\n#' pc: flag to adapt the algorithm in order to bahave as\n#'     pc algorithm\n#' originalEdges: true MAMP model\n#' counters: counters for rules and steps application\n#' edgesInfo: info about edges. This is needed to store\n#' the required decoration for both sides of every edge\n#' graph: graph with the structure of the model. Used for\n#'        making easier the computation of adjacents\n#' separators: list of separators between nodes\n#'##############################################################\nMAMPCGSearch <- R6Class(\n  \"MAMPCGSearch\",\n  public=list(\n    #'##############################################################\n    #' class contructor\n    #' @param net\n    #' @param data\n    #' @param moral\n    #' @param pc\n    #' @param alpha\n    #' @param edges\n    #' @param debug\n    #'############################################################## \n    initialize=function(net, data, moral=TRUE, pc=FALSE, alpha, edges=NULL, debug=FALSE){\n      # sets debug flag\n      private$debug <- debug\n      \n      # sets moral flag\n      private$moral <- moral\n      \n      # sets net data member\n      private$net <- net\n\n      # stores the data\n      private$data <- data\n      \n      # stores alpha value\n      private$alpha <- alpha\n      \n      # flag showing the learn method will be normal\n      # PC on dag\n      private$pc <- pc\n      \n      # stores the info about the original structure defined\n      # by edges and not by a net\n      private$originalEdges <- edges\n\n      # initializes the counters\n      private$testCounter <- 0\n      private$rule1Counter <- 0\n      private$rule2Counter <- 0\n      private$rule3Counter <- 0\n      private$rule4Counter <- 0\n      private$step10Counter <- 0\n      private$step12Counter <- 0\n      private$step13Counter <- 0\n      private$step14Counter <- 0\n      private$step15Counter <- 0\n      \n      # creates an empty data frame with columns named from, to, left,\n      # and right\n      private$edgesInfo <- data.frame(from=character(), to=character(), \n                                      left=character(), right=character(), \n                                      stringsAsFactors=FALSE)\n      \n      # creates an empty graph for these nodes\n      private$graph <- bnlearn::empty.graph(names(data))\n      \n      # gets all the pairs of nodes\n      combinations=combn(names(data), 2)\n      \n      # adds the set of undirected edges. The length of combinations is\n      # divided by two just beacuse it contains pairs of elements. This is\n      # achieved selecting all the columns\n      for(i in 1:length(combinations[1,])){\n        \n        # adds the corresponding undirected arc\n        private$edgesInfo[i,] <- c(combinations[1,i], combinations[2,i],\"none\",\"none\")\n        \n        # add the edge\n        private$graph <- bnlearn::set.edge(private$graph,from=combinations[1,i],to=combinations[2,i],\n                                  check.cycles=FALSE, debug=FALSE)\n      }\n      \n      # creates an empty list for separators\n      private$separators <- list()\n    },\n    \n    #'##############################################################\n    #' compares structures between this object and the true\n    #' net (stored in private$net)\n    #' moral argument to show if v-structures must consider triplexes\n    #' A -> B <- C with A and C as adjacents or not (TRUE this v-structure\n    #' is considered; with false this is not a valid v-structure)\n    #'##############################################################\n    compareStructure = function(){\n      if (private$debug){\n        cat(\"\\n -------------------------- compareStructure begin ---------------------\\n\")\n      }\n      \n      # compares the structures\n      # gets the skeleton of the true net\n      sk <- bnlearn::empty.graph(nodes(private$net))\n      bnlearn::amat(sk,ignore.cycles=TRUE) <- bnlearn::amat(private$net)\n      trueDependenceGraph <- bnlearn::skeleton(sk)\n\n      # gets th skeleton of the current graph\n      sk <- bnlearn::empty.graph(nodes(private$graph))\n      bnlearn::amat(sk,ignore.cycles=TRUE) <- bnlearn::amat(private$graph)\n      currentDependenceGraph <- bnlearn::skeleton(sk)\n\n      # se realiza la comparacion\n      result <- compare(trueDependenceGraph,currentDependenceGraph,arcs=FALSE)\n      \n      # now computes the precision and recall measurements\n      recall <- result$tp/(result$tp+result$fn)\n      precision <- result$tp/(result$tp+result$fp)\n      cat(\"Recall: \",recall,\" precision: \",precision,\"\\n\")\n\n      # now get the vstructures of the true net\n      if (is.null(private$originalEdges)){\n        trueVsdf <- as.data.frame(vstructs(as.bn(modelstring(private$net)), moral=private$moral), \n                                  stringsAsFactors=FALSE)\n        \n        # adds a new column with the type\n        trueVsdf[,\"type\"] <- c(rep(1,nrow(trueVsdf)))\n        if (private$debug){\n          cat(\"V-structures in true net (computed with net information): \\n\")\n          print(trueVsdf)\n          cat(\"---------------------------------------------\\n\")\n        }\n      }\n      else{\n        trueVsdf <- private$getModelVStructuresDataFrame(private$originalEdges)\n        if (private$debug){\n          cat(\"V-structures in original net (computed with edges information): \\n\")\n          print(trueVsdf)\n          cat(\"---------------------------------------------\\n\")\n        }\n      }\n            \n      # gets th vstructures of the learnt model\n      currentVsdf <- private$getModelVStructuresDataFrame(private$edgesInfo)\n      if (private$debug){\n        cat(\"V-structures in learnt net: \\n\")\n        print(currentVsdf)\n        cat(\"---------------------------------------------\\n\")\n      }\n      \n      # now compares both sets of vstructures\n      resultVs <- private$compareVStructures(trueVsdf,currentVsdf)\n      recallVs <- resultVs$recall\n      precisionVs <- resultVs$precision\n      cat(\"RecallVs: \",recallVs,\" precisionVs: \",precisionVs,\"\\n\\n\")\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- compareStructure end ---------------------\\n\")\n      }\n      \n      # check for NAs and change with 0\n      if (is.na(precision)){\n         precision=0\n      }\n      if (is.na(precisionVs)){\n         precisionVs=0\n      }\n      \n      # finally returns all this measurements\n      return(list(recall=recall, precision=precision, recallVs=recallVs, precisionVs=precisionVs))\n    },\n    \n    #'##############################################################\n    #' sets edgesInfo information. This is used only for testing\n    #' @param edges\n    #'##############################################################\n    setEdgesInfo = function(edges){\n      private$edgesInfo <- edges\n    },\n    \n    #'##############################################################\n    #' sets graph data member. This is used only for testing\n    #' @param graph\n    #'##############################################################\n    setGraph = function(graph){\n      private$graph <- graph\n    },\n    \n    #'##############################################################\n    #' tests rule1 application. Used for testing\n    #'##############################################################\n    testRule1 = function(){\n      if (private$debug){\n        cat(\"\\n -------------------------- testRule1 begin ---------------------\\n\")\n      }\n      \n      # applies initialLoop\n      private$initialLoop()\n      \n      if (private$debug){\n        cat(\"Initial loop end: apply rule 1 phase ................... \\n\")\n      }\n      \n      # show info about bInfo with separators info\n      self$show(TRUE)\n      \n      # applies rule 1\n      flag <- TRUE\n      while(flag){\n        flag <- private$applyRule1()\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- testRule1 end ---------------------\\n\")\n      }\n    },\n    \n    #'##############################################################\n    #' tests rule2 application. Used for testing\n    #'##############################################################\n    testRule2 = function(){\n      if (private$debug){\n        cat(\"\\n -------------------------- testRule2 begin ---------------------\\n\")\n      }\n      \n      # show info about bInfo with separators info\n      self$show(TRUE)\n      \n      # applies rule 1\n      flag <- TRUE\n      while(flag){\n        flag <- private$applyRule2()\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- testRule2 end ---------------------\\n\")\n      }\n    },\n    \n    #'##############################################################\n    #' tests rule3 application. Used for testing\n    #'##############################################################\n    testRule3 = function(){\n      private$applyRule3()\n    },\n    \n    #'##############################################################\n    #' tests rule 4 application. Used for testing\n    #'##############################################################\n    testRule4 = function(){\n      private$applyRule4()\n    },\n    \n    #'##############################################################\n    #' tests the application of the step 10\n    #'##############################################################\n    testStep10 = function(){\n      # applies initialLoop\n      private$initialLoop()\n      \n      result <- TRUE\n      while(result == TRUE){\n        result <- private$changeEdgesInCycle()\n      }\n    },\n    \n    #'##############################################################\n    #' tests the learn algorithm without making independence tests. Only\n    #' for testing purposes\n    #'##############################################################\n    testLearn = function(){\n      if (private$debug){\n        cat(\"Begin of rules 1 - 2 - 3 - 4 application\\n\")\n      }\n            \n      # loop of rules application\n      rules <- c(TRUE,TRUE,TRUE,TRUE)\n      private$applyRules(rules)\n      \n      \n      if (private$debug){\n        cat(\"End of rules 1 - 2 - 3 - 4 application\\n\")\n      }\n      \n      if (private$debug){\n        cat(\"Step 10 application\\n\")\n      }\n      \n      # applies step 10\n      result <- TRUE\n      while(result){\n        result <- private$changeEdgesInCycle()\n      }\n      \n      if (private$debug){\n        cat(\"End of step 10 application\\n\")\n      }\n      \n      if (private$debug){\n        cat(\"Begin of rules 2 - 3 - 4 application\\n\")\n      }\n      \n      # applies rules 2, 3 and 4\n      # loop of rules application\n      rules <- c(FALSE,TRUE,TRUE,TRUE)\n      private$applyRules(rules)\n      \n      if (private$debug){\n        cat(\"End of rules 2 - 3 - 4 application\\n\")\n      }\n      \n      if (private$debug){\n        cat(\"Step 12 application\\n\")\n      }\n      \n      # now changes edges block-wildcard by none-arrow (step 12)\n      counter <- private$changeEdgesDecoration(\"block\",\"none\",\"none\",\"arrow\")\n      private$step12Counter <- private$step12Counter+counter\n      \n      if (private$debug){\n        cat(\"End of step 12 application\\n\")\n      }\n      \n      if (private$debug){\n        cat(\"Step 13 application\\n\")\n      }\n      \n      # now changes edges block-block by arrow-arrow (step 13)\n      counter <- private$changeEdgesDecoration(\"block\",\"block\",\"arrow\",\"arrow\")\n      private$step13Counter <- private$step13Counter+counter\n      \n      if (private$debug){\n        cat(\"End of tep 13 application\\n\")\n      }\n      \n      if (private$debug){\n        cat(\"Step 14 application\\n\")\n      }\n      \n      # apply step 14 \n      result <- TRUE\n      while(result){\n        result <- private$applyStep14()\n      }\n      \n      if (private$debug){\n        cat(\"End of step 14 application\\n\")\n      }\n      \n      if (private$debug){\n        cat(\"Step 15 application\\n\")\n      }\n      \n      # apply step 15 while true\n      result <- TRUE\n      while(result){\n        result <- private$applyStep15()\n      }\n      \n      if (private$debug){\n        cat(\"End of step 15 application\\n\")\n      }\n    },\n    \n    #'##############################################################\n    #' tests the decoration changes. Only for testing\n    #'##############################################################\n    testChangeEdgesDecoration = function(){\n      private$changeEdgesDecoration(\"block\",\"block\",\"none\",\"none\")\n    },\n    \n    #'##############################################################\n    #' add separators info just for testing. Only for testing\n    #' @param pair pair of nodes\n    #' @param separatorSet separators for nodes in pair\n    #'##############################################################\n    addSeparator = function(pair, separatorSet){\n      private$storeSeparatorInfo(pair,separatorSet)\n    },\n    \n    #'##############################################################\n    #' main method for learning\n    #'##############################################################\n    learn=function(){\n      if (private$debug){\n        cat(\"\\n -------------------------- learn begin ---------------------\\n\")\n        cat(\"PC mode: \",private$pc,\"\\n\")\n      }\n      \n      # applies initialLoop\n      private$initialLoop()\n            \n      if (private$debug){\n        cat(\"Begin of rules 1 - 2 - 3 - 4 application\\n\")\n      }\n      \n      # loop of rules application\n      rules <- c(TRUE,TRUE,TRUE,TRUE)\n      private$applyRules(rules)\n      \n      \n      if (private$debug){\n        cat(\"End of rules 1 - 2 - 3 - 4 application\\n\")\n      }\n      \n      # step 10 only works in mampc mode\n      if (!private$pc){\n        if (private$debug){\n          cat(\"Step 10 application\\n\")\n        }\n      \n        # applies step 10\n        result <- TRUE\n        while(result){\n          result <- private$changeEdgesInCycle()\n        }\n      \n        if (private$debug){\n          cat(\"End of step 10 application\\n\")\n        }\n      }\n      \n      # step 11 only works in mampc mode\n      if (!private$pc){\n        if (private$debug){\n          cat(\"Begin of rules 2 - 3 - 4 application\\n\")\n        }\n      \n        # applies rules 2, 3 and 4\n        # loop of rules application\n        rules <- c(FALSE,TRUE,TRUE,TRUE)\n        private$applyRules(rules)\n      \n        if (private$debug){\n          cat(\"End of rules 2 - 3 - 4 application\\n\")\n        }\n      }\n      \n      if (private$debug){\n        cat(\"Step 12 application\\n\")\n      }\n      \n      # now changes edges block-wildcard by none-arrow (step 12)\n      counter <- private$changeEdgesDecoration(\"block\",\"none\",\"none\",\"arrow\")\n      private$step12Counter <- private$step12Counter+counter\n      \n      if (private$debug){\n        cat(\"End of step 12 application\\n\")\n      }\n      \n      # step 13 only works in mampc mode\n      if (!private$pc){\n        if (private$debug){\n          cat(\"Step 13 application\\n\")\n        }\n      \n        # now changes edges block-block by arrow-arrow (step 13)\n        counter <- private$changeEdgesDecoration(\"block\",\"block\",\"arrow\",\"arrow\")\n        private$step13Counter <- private$step13Counter+counter\n      \n        if (private$debug){\n          cat(\"End of tep 13 application\\n\")\n        }\n      }\n      \n      # step 14 only works in mampc mode\n      if (!private$pc){\n        if (private$debug){\n          cat(\"Step 14 application\\n\")\n        }\n      \n        # apply step 14 \n        result <- TRUE\n        while(result){\n          result <- private$applyStep14()\n        }\n      \n        if (private$debug){\n          cat(\"End of step 14 application\\n\")\n        }\n      }\n      \n      # step 14 only works in mampc mode\n      if (!private$pc){\n        if (private$debug){\n          cat(\"Step 15 application\\n\")\n        }\n      \n        # apply step 15 while true\n        result <- TRUE\n        while(result){\n          result <- private$applyStep15()\n        }\n      \n        if (private$debug){\n          cat(\"End of step 15 application\\n\")\n        }\n      }\n      \n      # finally takes teh changes to graph in pc mode\n      if(private$pc){\n        private$updateGraph()\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- learn end ---------------------\\n\")\n      }\n    },\n        \n    #'##############################################################\n    #' method for showing the data contained by the object\n    #'##############################################################\n    show = function(showSeparators=FALSE){\n      if (private$debug){\n        cat(\"\\n -------------------------- BuildInfo object ---------------------\\n\")\n        cat(\"PC mode: \",private$pc,\"\\n\")\n        cat(\"Edges info: \\n\")\n        cat(\"Number of edges: \",nrow(private$edgesInfo),\"\\n\")\n        print(private$edgesInfo)\n        cat(\"....................................................................\\n\")\n        cat(\"Associated bn: \\n\")\n        print(private$graph)\n        cat(\"Nodes in graph: \",nodes(private$graph),\"\\n\")\n        cat(\"Show separators info: \",showSeparators,\"\\n\")\n        if (showSeparators == TRUE){\n          cat(\"....................................................................\\n\")\n          cat(\"Separators set: \\n\")\n          print(private$separators)\n          cat(\"....................................................................\\n\")\n        }\n        cat(\"Tests counter: \",private$testCounter,\"\\n\")\n        cat(\"Rule 1 counter: \",private$rule1Counter,\"\\n\")\n        cat(\"Rule 2 counter: \",private$rule2Counter,\"\\n\")\n        cat(\"Rule 3 counter: \",private$rule3Counter,\"\\n\")\n        cat(\"Rule 4 counter: \",private$rule4Counter,\"\\n\")\n        cat(\"Step 10 counter: \",private$step10Counter,\"\\n\")\n        cat(\"Step 12 counter: \",private$step12Counter,\"\\n\")\n        cat(\"Step 13 counter: \",private$step13Counter,\"\\n\")\n        cat(\"Step 14 counter: \",private$step14Counter,\"\\n\")\n        cat(\"Step 15 counter: \",private$step15Counter,\"\\n\")\n      }\n    }\n  ),\n  \n  #'##############################################################\n  #' PRIVATE SECTION OF THE CLASS\n  #'##############################################################  \n  # all the data are kept private as well as some auxiliar functions\n  private = list(\n    net=\"bn.fit\",\n    data=\"data.frame\",\n    moral=\"logical\",\n    alpha=\"numeric\",\n    pc=\"logical\",\n    edgesInfo=\"data.frame\",\n    graph=\"bn\",\n    separators=\"list\",\n    originalEdges=\"data.frame\",\n    debug=\"logical\",\n    testCounter=\"numeric\",\n    rule1Counter=\"numeric\",\n    rule2Counter=\"numeric\",\n    rule3Counter=\"numeric\",\n    rule4Counter=\"numeric\",\n    step10Counter=\"numeric\",\n    step12Counter=\"numeric\",\n    step13Counter=\"numeric\",\n    step14Counter=\"numeric\",\n    step15Counter=\"numeric\",\n    \n    #'##############################################################\n    #' method performing the first stage of the algorithm\n    #'##############################################################\n    initialLoop=function(){\n      if (private$debug){\n        cat(\"\\n -------------------------- initialLoop begin ---------------------\\n\")\n        self$show()\n      }\n      \n      # initializes l to 0\n      l <- 0\n      \n      # gets the number of nodes\n      nnodes <- length(nodes(private$graph))\n      \n      # main loop\n      while(l <= (nnodes-2)){\n        if (private$debug){\n          cat(\"Loop for l: \",l,\"\\n\")\n        }\n        \n        # forms the pairs of nodes\n        pairs <- combn(bnlearn::nodes(private$graph),2)\n        # forms the pairs of nodes\n        pairs <- combn(bnlearn::nodes(private$graph),2)\n        pairs1 <- lapply(seq_len(ncol(pairs)), function(i) {c(pairs[1,i],pairs[2,i])})\n        pairs2 <- lapply(seq_len(ncol(pairs)), function(i) {c(pairs[2,i],pairs[1,i])})\n        pairs <- append(pairs1,pairs2)\n        \n        # gets the pairs with the proper conditions\n        filteredPairs <- lapply(pairs, private$treatPair, l=l)\n        \n        # adds 1 to l\n        l <- l+1\n      }\n      if (private$debug){\n        cat(\"\\n -------------------------- initialLoop end ---------------------\\n\")\n      }\n    },\n    \n    #'##############################################################\n    #' private method for making the operations with a pair of nodes to detect\n    #' independence/dependence\n    #'##############################################################\n    treatPair=function(pair, l){\n      if (private$debug){\n        cat(\"\\n -------------------------- treatPair begin ---------------------\\n\")\n        cat(\"Pair to be tested for l =\",l, \" \\n\")\n        print(pair)\n      }\n      \n      # check the conditions in order to apply the test\n      result <- private$checkConditionsTestAnalysis(pair, l)\n      \n      # if the flag of result is TRUE, it is needed to make\n      # independence tests\n      if (result$flag == TRUE){\n        # make the tests of this pair\n        private$makeTests(pair,l,result$set)\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- treatPair end ---------------------\\n\")\n      }\n    },\n        \n    #'##############################################################\n    #' function for making the independence tests on a pair of nodes\n    #'##############################################################\n    makeTests=function(pair,l,set){\n      if (private$debug){\n        cat(\"\\n -------------------------- makeTests begin ---------------------\\n\")\n      }\n      \n      # makes all the sets of size equals to l\n      sets <- combn(set,l)\n      \n      # if l is 0, sets will be be a list with an empty list\n      if (length(sets) == 0){\n        sets <- list(list())\n      }\n      else{\n        sets <- lapply(seq_len(ncol(sets)), function(i) {\n          separatorSet <- list()\n          for(j in 1:l){\n            separatorSet[j] <- sets[j,i]\n          }\n          separatorSet\n        })\n      }\n      \n      # now considers every set and make the corresponding independence\n      # test. If the rest result is positive, change the graph and the\n      # info about edges. This must be done in a loop style in order to\n      # avoid useless tests\n      if (private$debug){\n        cat(\"Set of possible separators: \\n\")\n        for(i in 1:length(sets)){\n          cat(\" \",unlist(sets[[i]]), \" \")\n        }\n        cat(\"\\n\")\n        cat(\"Number of candidates: \",length(sets),\"\\n\")\n      }\n      \n      for(i in 1:length(sets)){\n        # gets the separator\n        separator <- as.character(sets[[i]])\n        \n        #if (length(separator) == 0){\n        #  separator <- NULL\n        #}\n        \n        if (private$debug){\n          cat(\"Longth of separator: \", length(separator),\"\\n\")\n          cat(\"Separator: |\",separator,\"|\\n\")\n          cat(\"x: \")\n          print(pair[[1]])\n          cat(\"y: \")\n          print(pair[[2]])\n        }\n        \n        # makes the test\n        if (!is.null(private$originalEdges)){\n          # continuous case\n          testResult <- bnlearn::ci.test(x=pair[[1]], y=pair[[2]],z=separator,private$data,test=\"mi-g\")\n        }\n        else{\n          # discrete case\n          testResult <- bnlearn::ci.test(x=pair[[1]], y=pair[[2]],z=separator,private$data,test=\"mi\")\n        }\n        \n        # increments the counter of test\n        private$testCounter <- private$testCounter+1\n        \n        if (private$debug){\n          cat(\"Test for \",pair[[1]],\" - \",pair[[2]], \" separator: \")\n          print(separator)\n          cat(\"test result: \\n\")\n          print(testResult)\n        }\n        \n        # if p-value >= alpha, considers independence\n        if (testResult$p.value >= private$alpha){\n          if (private$debug){\n            cat(\"removing edge...............\\n\")\n          }\n          \n          # removes the edge\n          private$removeEdge(pair)\n          \n          # stores information about separator\n          if(is.null(separator)){\n            separator <- list()\n          }\n          private$storeSeparatorInfo(pair,separator)\n          \n          # in order to debug the code, shows the result\n          if(private$debug){\n            cat(\"--------------------- Current state --------------------\\n\")\n            self$show()\n            cat(\"--------------------------------------------------------\\n\")\n            cat(\"\\n\")\n          }\n          \n          # breaks the loop\n          break\n        }\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- makeTests end ---------------------\\n\")\n      }\n    },\n    \n    #'##############################################################\n    #' method to remove an edge in the graph\n    #' arguments:\n    #' @param pair pair of nodes defining the edge. It is not possible\n    #'         the existance of several edges between a pair of nodes\n    #'##############################################################\n    removeEdge=function(pair){\n      if (private$debug){\n        cat(\"\\n -------------------------- removeEdge begin ---------------------\\n\")\n        cat(\"Removing edge \",pair[[1]], \" - \",pair)\n      }\n      \n      # removes the edge from the graph\n      private$graph <- bnlearn::drop.edge(private$graph,pair[[1]],pair[[2]])\n      \n      # removes the info about this edge\n      private$edgesInfo <- private$edgesInfo[!(private$edgesInfo$from == pair[[1]] &\n                                                 private$edgesInfo$to == pair[[2]]),]\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- removeEdge end ---------------------\\n\")\n      }\n    },\n    \n    #'##############################################################\n    #' method to store information about separator\n    #' arguments: \n    #' @param pair: pair of nodes under analysis\n    #' @param separtor: separator set for nodes in pair\n    #'##############################################################\n    storeSeparatorInfo=function(pair, separator){\n      if (private$debug){\n        cat(\"\\n -------------------------- storeSeparator begin ---------------------\\n\")\n        cat(\"Separator for \",pair[[1]], \" - \",pair[[2]],\"\\n\")\n        cat(\"Separator set: \\n\")\n        print(separator)\n      }\n      \n      # forms both keys\n      keyab=paste(pair[[1]],pair[[2]],sep=\"\")\n      keyba=paste(pair[[2]],pair[[1]],sep=\"\")\n      \n      # stores the info\n      private$separators[[keyab]] <- separator\n      private$separators[[keyba]] <- separator\n      if (private$debug){\n        cat(\"\\n -------------------------- storeSeparator end ---------------------\\n\")\n      }\n    },\n    \n    #'##############################################################\n    #' method for applying the rules once and again while possible\n    #' arguments:\n    #' @param rules logical vector with boolean flags for rule1, rule2,\n    #'         rule3 and rule4\n    #'##############################################################\n    applyRules = function(rules){\n      if (private$debug){\n        cat(\"\\n -------------------------- applyRules begin ---------------------\\n\")\n      }\n      keep <- TRUE\n      # Sets flags to false to avoid problems if the rules will not\n      # be applied\n      flag1 <- FALSE\n      flag2 <- FALSE\n      flag3 <- FALSE\n      flag4 <- FALSE\n      \n      # apply every rule as much as possible\n      while(keep){\n        if (private$debug){\n          cat(\"....................... rule application loop ......................\\n\")\n          self$show(TRUE)\n        }\n        \n        # applies rule 1\n        if (rules[1] == TRUE){\n          flag1 <- private$applyRule1()\n        }\n        \n        # applies rule 2\n        if (rules[2] == TRUE){\n          flag2 <- private$applyRule2()\n        }\n        \n        # applies rule 3\n        if (rules[3] == TRUE){\n          flag3 <- private$applyRule3()\n        }\n        \n        # applies rule 3\n        if (rules[4] == TRUE){\n          flag4 <- private$applyRule4()\n        }\n        \n        # updates keep value\n        keep <- flag1 | flag2 | flag3 | flag4\n        \n        if (private$debug){\n          cat(\"flag1: \",flag1, \" flag2: \", flag2, \" flag3: \", flag3, \" flag4: \",flag4,\"\\n\")\n          cat(\"Value of keep in rules application: \",keep,\"\\n\")\n        }\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- applyRules end ---------------------\\n\")\n        cat(\"flag1: \",flag1, \" flag2: \", flag2, \" flag3: \", flag3, \" flag4: \",flag4,\"\\n\")\n        cat(\"------------------------------------------------------------------\\n\")\n      }\n    },\n    \n    #'##############################################################\n    #' method for rule 1 application\n    #'##############################################################\n    applyRule1 = function(){\n      if (private$debug){\n        cat(\"\\n -------------------------- applyRule1 begin ---------------------\\n\")\n      }\n\n      # flag to show if the rule was applied\n      applied <- FALSE\n      \n      # get pairs with a common node\n      pairs <- private$matchEdgesWithCommonNode(private$edgesInfo)\n      \n      # filter pairs by separators: in this case B must not be included in\n      # the separator set for A and B\n      pairs <- private$filterPairsBySeparators(pairs, FALSE)\n            \n      # # generate a data frame if there are pairs; in any other case\n      # NULL will be returned\n      candidatePairsdf <- private$generateAlignmentDataFrame(pairs)\n      \n      # checks if there a pair and selects pairs of edges with the required pattern\n      if (private$containsData(candidatePairsdf)){\n        # selects the pattern block - wildcard - wildcard - wildcard\n        candidatePairsdf <- private$selectPairPattern(candidatePairsdf, \"wildcard\",\"wildcard\", \n                                                      \"wildcard\", \"noblock\")\n                \n        # considers every candidate and breaks the loop if one is found\n        if (private$containsData(candidatePairsdf)){\n          for(i in 1:nrow(candidatePairsdf)){\n            # selects the corresponding pair of edges\n            pairInfo <- candidatePairsdf[i, ]\n            \n            # check the existence of an directed edge between the extremes\n            acEdge <- private$checkEdgeInArgumentEdges(pairInfo$anode,pairInfo$cnode,private$edgesInfo)\n                   \n            # change decoration and breaks the loop\n            if (!acEdge){\n              # change edge info: first edge becomes block-wildcard and second\n              # becomes wildcard-block.\n              changed1 <- private$changeEdgeDecoration(pairInfo$anode, pairInfo$bnode, \n                                           \"block\", \"wildcard\")\n              changed2 <- private$changeEdgeDecoration(pairInfo$bnode, pairInfo$cnode,\n                                           \"wildcard\", \"block\")\n              \n              if (changed1 & changed2){\n                # adds 1 to rule1Counter\n                private$rule1Counter <- private$rule1Counter+1\n              \n                # sets applied be true\n                applied <- TRUE\n              \n                # breaks the loop\n                break\n              }\n              else{\n                # restore the edge changed\n                if (changed1){\n                  private$changeEdgeDecoration(pairInfo$anode,pairInfo$bnode,\n                                                 pairInfo$adeco,pairInfo$bdeco1)\n                }\n                if (changed2){\n                  private$changeEdgeDecoration(pairInfo$bnode,pairInfo$cnode,\n                                                 pairInfo$bdeco2,pairInfo$cdeco)\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- applyRule1 end ---------------------\\n\")\n        cat(\"Applied: \",applied,\"\\n\")\n        cat(\"\\n ---------------------------------------------------------------\\n\")\n      }\n      \n      # return applied\n      return(applied)\n    },\n    \n    #'##############################################################\n    #' method for rule 2 application\n    #'##############################################################\n    applyRule2 = function(){\n      if (private$debug){\n        cat(\"\\n -------------------------- applyRule2 begin ---------------------\\n\")\n      }\n      \n      # flag to show if the rule was applied\n      applied <- FALSE\n      \n      # get pairs with a common node\n      pairs <- private$matchEdgesWithCommonNode(private$edgesInfo)\n      \n      # filter pairs by separators: in this case B must be included in\n      # the separator set for A and B\n      pairs <- private$filterPairsBySeparators(pairs, TRUE)\n      \n      # # generate a data frame if there are pairs; in any other case\n      # NULL will be returned\n      candidatePairsdf <- private$generateAlignmentDataFrame(pairs)\n      \n      # checks if there a pair\n      if (private$containsData(candidatePairsdf)){\n        # selectes the pattern block - wildcard - wildcard - wildcard\n        candidatePairsdf <- private$selectPairPattern(candidatePairsdf, \"block\",\n                                              \"wildcard\", \"noblock\", \"wildcard\")\n        \n        # considers every candidate and breaks the loop if one if found\n        if (private$containsData(candidatePairsdf)){\n          for(i in 1:nrow(candidatePairsdf)){\n            pairInfo <- candidatePairsdf[i, ]\n            \n            # check the existence of an directed edge between the extremes\n            acEdge <- private$checkEdgeInArgumentEdges(pairInfo$anode,pairInfo$cnode,private$edgesInfo)\n            \n            # if flag is true change edges decoration on the extremes\n            # not in common\n            if (!acEdge){\n              # change edge info: first edge remains and the second becomes to\n              # block-wildcard\n              changed <- private$changeEdgeDecoration(pairInfo$bnode, pairInfo$cnode,\n                                   \"block\", \"wildcard\")\n              \n              if (changed){\n                # adds 1 to rule2Counter\n                private$rule2Counter <- private$rule2Counter+1\n              \n                # sets 1 to applied\n                applied <- TRUE\n              \n                # break the loop\n                break\n              }\n            }\n          }\n        }\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- applyRule2 end ---------------------\\n\")\n        cat(\"Applied: \",applied,\"\\n\")\n        cat(\"\\n ---------------------------------------------------------------\\n\")\n      }\n      \n      # return applied\n      return(applied)\n    },\n    \n    #'##############################################################\n    #' method for rule 3 application. The change in edges and the increment\n    #' in the counter are made in auxiliar methods\n    #'##############################################################\n    applyRule3 = function(){\n      if (private$debug){\n        cat(\"\\n -------------------------- applyRule3 begin ---------------------\\n\")\n      }\n      # considers from-to direction\n      flag <- private$applyRule3WithDirection(FALSE)\n      \n      # if the rule was not applied, considers the opposite direction\n      if (flag == FALSE){\n        flag <- private$applyRule3WithDirection(TRUE)\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- applyRule3 end ---------------------\\n\")\n      }\n      \n      # return flag\n      return(flag)\n    },\n    \n    #'##############################################################\n    #' method for rule 4 application\n    #'##############################################################\n    applyRule4=function(){\n      if (private$debug){\n        cat(\"\\n -------------------------- applyRule4 begin ---------------------\\n\")\n      }\n      \n      # begins with the flag set to FALSE\n      applied <- FALSE\n      \n      # gets the pairs with a common node\n      pairs <- private$matchEdgesWithCommonNode(private$edgesInfo)\n      \n      # generates a data frame if there are pairs; in any other case\n      # NULL will be returned\n      candidatePairsdf <- private$generateAlignmentDataFrame(pairs)\n      \n      # checks if there are some pair\n      if(private$containsData(candidatePairsdf)){\n        # selects the target pattern: wildcard-wildcard-block-wildcard\n        candidatePairsdf <- private$selectPairPattern(candidatePairsdf, \"wildcard\",\"wildcard\",\n                                                      \"block\",\"wildcard\")\n        \n        if (private$debug){\n          cat(\"Pair of edges with wildcard - wildcard - block - wildcard pattern: \",nrow(candidatePairsdf),\"...............\\n\")\n          print(candidatePairsdf)\n        }\n        \n        # now get sets of two pairs in order to get the rombus\n        # pattern for thr rule 4 application\n        if (private$containsData(candidatePairsdf) & nrow(candidatePairsdf) > 1){\n          # gets the quartets\n          quartets <- private$getQuartets(candidatePairsdf)\n          \n          # checks if quartets is null\n          if (private$containsData(quartets)){\n            if (private$debug){\n              cat(\"Quartets for rule application: \",nrow(quartets),\"...............\\n\")\n              print(quartets)\n            }\n            \n            # if there are quartets, check if the rule can be applied,\n            # being a in the separator set of CD\n            if (length(quartets) != 0){\n              quartet <- quartets[[1]][[1]]\n              result <- private$checkConditionForRule4(quartet)\n              \n              # if flag is true then the link between quartet$pair1$anode and\n              # quartet$pair2$cnode can ne changed\n              if (result$flag){\n                if (private$debug){\n                  print(result)\n                }\n                \n                # changes the edge\n                changed <- private$changeEdgeDecoration(quartet$pair1$anode, quartet$pair1$cnode,\"block\",\"wildcard\")\n              \n                if (changed){\n                  # sets applied to true\n                  applied <- TRUE\n                \n                  # adds 1 to rule4Counter\n                  private$rule4Counter <- private$rule4Counter+1\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- applyRule4 end ---------------------\\n\")\n      }\n      \n      # return applied\n      return(applied)\n    },\n    \n    #'##############################################################\n    #' method for the application of step 10\n    #'##############################################################\n    changeEdgesInCycle = function(){\n      if (private$debug){\n        cat(\"\\n -------------------------- changeEdgesInCycle begin ---------------------\\n\")\n      }\n      \n      # initialize the process\n      lnodes <- bnlearn::nodes(private$graph)\n      nnodes <- length(lnodes)\n      flag <- FALSE\n      \n      # initially the list of edges is the whole set\n      edges  <- private$edgesInfo  \n      \n      # it is needed to consider every node\n      for(i in 1:nnodes){\n        \n        # selects the node\n        node <- lnodes[[i]]\n        \n        if (private$debug){\n          cat(\"Looking for loops from node \",node,\"\\n\")\n        }\n        \n        # checks if the node belongs to a cycle\n        result <- private$isReachableWithLoopAndDeco(node,node,\"noblock\",\"noblock\",\n                                                     list(), edges)\n        \n        if (private$debug){\n          cat(\"Result on investigate cycles from \",node,\"\\n\")\n          cat(\"result: \",result$flag,\"\\n\")\n          cat(\"Path: \\n\")\n          print(result$path)\n          cat(\"Length of path: \",result$length,\"\\n\")\n        }\n        \n        # is is reachable in a path without blocks and with length\n        # bigger or equal to 4, it is needed\n        # to change all the edges to block-block\n        if (result$flag == TRUE){   \n          # first at all checks the induced subgraph\n          subgraph <- private$getInducedSubgraph(result$path)\n          if (private$debug){\n            cat(\"Path with loop detected: \\n\")\n            print(subgraph)\n          }\n          \n          if (result$length > 3 & nrow(subgraph) == result$length){\n            flag <- TRUE\n            \n            # change edges in path\n            private$changeEdgesInPath(result$path,\"block\",\"block\") \n            \n            # adds 1 to the counter\n            private$step10Counter <- private$step10Counter+1\n            \n            # break the loop\n            break  \n          }\n          else{              \n            # remove the edges contained in path\n            edges <- private$removeEdgesInArgumentInPath(result$path, edges)\n            \n            if (private$debug){\n              cat(\"Reduced the set of edges for further exploration: \\n\")\n              print(edges)\n            }\n          }            \n        }\n        else{\n          # if there is a loop, remove the edges in it\n          if (result$loop == TRUE){\n            if (private$debug){\n              cat(\"Loop detection for previous nodes\\n\")\n              print(result$path)\n            }\n            edges <- private$removeEdgesInArgumentInCycle(result$path, edges)\n          }\n        }\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- changeEdgeInCycle end ---------------------\\n\")\n        cat(\"Flag value to return: \",flag,\"\\n\")\n      }\n      \n      # return the flag\n      return(flag)\n    },\n    \n    #'##############################################################\n    #' method for changing the decorations of the edges following a\n    #' certain pattern: the two first decorations are changed by\n    #' the new ones (needed for steps 12 and 13)\n    #' arguments:\n    #' @param deco1 actual decoration of one side\n    #' @param deco2 actual decoration of other side\n    #' @param newDeco1 new decoration for side1\n    #' @param newDeco2 new decoration for side2\n    #'##############################################################\n    changeEdgesDecoration = function(deco1, deco2, newDeco1, newDeco2){\n      if (private$debug){\n        cat(\"\\n -------------------------- changeEdgesDecoration begin ---------------------\\n\")\n        cat(\"deco1: \",deco1,\" deco2: \",deco2,\n            \" newDeco1: \",newDeco1, \" newdDeco2: \",newDeco2,\"\\n\")\n      }\n      \n      # sets counter to 0\n      counter <- 0\n      \n      # get the edges with deco1 in left and deco2 in right\n      directedEdges <- private$getEdgesWithPatternFromTo(deco1,deco2)\n\n      # changes the edges decoration\n      if (private$containsData(directedEdges)){\n        counter <- counter+nrow(directedEdges)\n        # changes all of them\n        apply(directedEdges, 1, function(edge){\n          edge <- unlist(edge)          \n          private$changeEdgeDecoration(edge[\"from\"],edge[\"to\"],newDeco1,newDeco2)\n        })\n        \n        if (private$debug){\n          cat(\"inverted edges in from - to direction\\n\")\n        }\n      }\n            \n      # the same with the set of inverted edges\n      invertedEdges <- private$getEdgesWithPatternFromTo(deco2,deco1)\n      \n      # changes the edges decoration\n      if (private$containsData(invertedEdges)){\n        counter <- counter+nrow(invertedEdges)\n        # change all of them\n        apply(invertedEdges, 1, function(edge){\n          edge <- unlist(edge)        \n          private$changeEdgeDecoration(edge[\"from\"],edge[\"to\"],newDeco2,newDeco1)\n        })\n        \n        if (private$debug){\n          cat(\"inverted edges in to - from direction\\n\")\n        }\n        \n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- changeEdgesDecoration end ---------------------\\n\")\n      }\n      \n      # return flag\n      return(counter)\n    },\n    \n    #'##############################################################\n    #' method for step14 application\n    #'##############################################################\n    applyStep14 = function(){\n      if (private$debug){\n        cat(\"\\n -------------------------- applyStep14 begin ---------------------\\n\")\n      }\n      \n      # flag to show if the rule was applied\n      applied <- FALSE\n      \n      # get pairs of edges with common node\n      pairs <- private$matchEdgesWithCommonNode(private$edgesInfo)\n      \n      if (private$debug){\n        cat(\"Pairs of edges with common node: \\n\")\n        print(pairs)\n      }\n            \n      # considers the pairs\n      if (private$containsData(pairs)){\n                \n        # selects pairs with pattern arrow - arrow - none - none\n        candidatePairsdf <- private$selectPairPattern(pairs, \"arrow\", \"arrow\",\n                                                      \"arrow\", \"arrow\")\n        \n        if (private$debug){\n          cat(\"Candidate pairs with pattern arrow - arrow - arrow - arrow \\n\")\n          print(candidatePairsdf)\n        }\n        \n        # considers every pair\n        if (private$containsData(candidatePairsdf)){\n          for(i in 1:nrow(candidatePairsdf)){\n            pairInfo <- candidatePairsdf[i,]\n            if (private$debug){\n              cat(\"Candidate pair for step 14 application: \\n\")\n              print(pairInfo)\n            }\n          \n            # checks the existence of a directed edge between the extremes\n            # in the induced subgraph \n            acEdge <- private$checkEdgeInArgumentEdges(pairInfo$anode,pairInfo$cnode,private$edgesInfo)\n          \n            # change decoration and breaks the loop\n            if (!acEdge){\n              # change edge info: both edges become none - none\n              private$changeEdgeDecoration(pairInfo$anode, pairInfo$bnode, \n                                         \"none\", \"none\")\n              private$changeEdgeDecoration(pairInfo$bnode, pairInfo$cnode, \n                                         \"none\", \"none\")\n              \n              print(\"Se suma 1 a step14Counter......\")\n            \n              # adds 1 to rule1Counter\n              private$step14Counter <- private$step14Counter+1\n            }\n          }\n        }\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- applyStep14 end ---------------------\\n\")\n        cat(\"Applied: \",applied,\"\\n\")\n        cat(\"\\n ---------------------------------------------------------------\\n\")\n      }\n      \n      # return applied\n      return(applied)\n    },\n    \n    #'##############################################################\n    #' method for step15 application\n    #'##############################################################\n    applyStep15 = function(){\n      if (private$debug){\n        cat(\"\\n -------------------------- applyStep15 begin ---------------------\\n\")\n      }\n      \n      # flag to show if the rule was applied\n      applied <- FALSE\n      \n      # get pairs with a common node\n      pairs <- private$matchEdgesWithCommonNode(private$edgesInfo)\n      \n      # # generate a data frame if there are pairs; in any other case\n      # NULL will be returned\n      candidatePairsdf <- private$generateAlignmentDataFrame(pairs)\n      \n      # checks if there a pair\n      if (private$containsData(candidatePairsdf)){\n        # selectes the pattern block - wildcard - wildcard - wildcard\n        candidatePairsdf <- private$selectPairPattern(candidatePairsdf, \n                                                      \"arrow\", \"arrow\", \"none\", \"none\")\n        \n        # considers every candidate and breaks the loop if one if found\n        if (private$containsData(candidatePairsdf)){\n            for(i in 1:nrow(candidatePairsdf)){\n              pairInfo <- candidatePairsdf[i, ]\n            \n              # this method also performs the changes in the edges\n              # in order to prepare the change in edgesInfo\n              directedEdge <- private$checkEdgeForNodesWithPattern(pairInfo$anode,pairInfo$cnode,\"none\",\"none\")\n            \n              # if flag is true change edges decoration on the extremes\n              # not in common\n              if (directedEdge){\n                # change the second edge\n                private$changeEdgeDecoration(pairInfo$anode,pairInfo$bnode,\"none\",\"none\")\n              \n                # set applies to true\n                applied <- TRUE\n              \n                # adds 1 to the counter\n                private$step15Counter <- private$step15Counter+1\n              \n                # break the loop\n                break\n             }\n           }\n        }\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- applyStep15 end ---------------------\\n\")\n        cat(\"Applied: \",applied,\"\\n\")\n        cat(\"\\n ---------------------------------------------------------------\\n\")\n      }\n      \n      # return applied\n      return(applied)\n    },\n    \n    #'##############################################################\n    #' method for changing an edge between two nodes. The new\n    #' edge decorations are stored in the argument\n    #' arguments:\n    #' @param edge edge eith information about involved nodes and\n    #'         new decorations\n    #'##############################################################\n    changeEdge = function(edge){\n      if (private$debug){\n        cat(\"\\n -------------------------- changeEdge begin ---------------------\\n\")\n        cat(\"Changing  edge:\\n\")\n        print(edge)\n      }\n      \n      # looks for the index of the corresponding edge in edgesInfo\n      index <- which(private$edgesInfo$from == edge$from & private$edgesInfo$to == edge$to)\n      cat(\"Indice: \",index)\n      \n      # if it is found, change it\n      if(length(index) == 1){\n        private$edgesInfo[index,] <- edge\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- changeEdge end ---------------------\\n\")\n      }\n    },\n    \n    #'##############################################################\n    #' method for changing the edges int the path\n    #' arguments:\n    #' @param path path where changes will be applied\n    #' @param deco1 decoration of a side\n    #' @param deco2 decoration of the other side\n    #'##############################################################\n    changeEdgesInPath = function(path, deco1, deco2){\n      if (private$debug){\n        cat(\"\\n -------------------------- changeEdgesInPath begin ---------------------\\n\")\n        cat(\"Path: \\n\")\n        print(path)\n        cat(\"deco1: \",deco1,\" deco2: \",deco2)\n      }\n      \n      # considers every edge\n      for(i in 1:length(path)){\n        index1 <- i\n        index2 <- i+1\n        if (index2 > length(path)){\n          index2=1\n        }\n        \n        # gets the next two nodes\n        anode <- path[[index1]]\n        bnode <- path[[index2]]\n        \n        # change the decorations to block-block\n        private$changeEdgeDecoration(anode,bnode,deco1,deco2)\n      }\n      if (private$debug){\n        cat(\"\\n -------------------------- changeEdgesInPath end ---------------------\\n\")\n      }\n    },\n        \n    #'##############################################################\n    #' look for edges containing node (as from or to) and having  \n    #' nodeDecorator on its side and otherDecorator in the opposite\n    #' one\n    #' arguments:\n    #' @param node node to look for in edges\n    #' @param nodeDecorator the method will work on edges having node\n    #                  and this decoration on a side\n    #' @param otherDecorator decoration for the other side\n    #' @param edges list of edges to analyze\n    #'##############################################################\n    getEdgesInArgumentForNode = function(node, nodeDecorator, otherDecorator, edges){\n      if (private$debug){\n        cat(\"\\n -------------------------- getEdgesInArgumentForNode begin ---------------------\\n\")\n        cat(\"Node: \",node, \"  node decorator: \",nodeDecorator, \" other decorator: \",otherDecorator,\" \\n\")\n        cat(\"List of edges: \\n\")\n        print(edges)\n      }\n      \n      # get edges outgoing from node\n      outgoingEdges <- edges[edges$from == node,]\n      \n      # considers left decoration if is not wildcard\n      if (nodeDecorator == \"noblock\"){\n        outgoingEdges <- outgoingEdges[outgoingEdges$left != \"block\",]\n      } \n      else{\n        if (nodeDecorator != \"wildcard\"){\n          outgoingEdges <- outgoingEdges[outgoingEdges$left == nodeDecorator,]\n        }\n      }\n      \n      # considers right decoration\n      if (otherDecorator == \"noblock\"){\n        outgoingEdges <- outgoingEdges[outgoingEdges$right != \"block\",]\n      }\n      else{\n        if (otherDecorator != \"wildcard\"){\n          outgoingEdges <- outgoingEdges[outgoingEdges$right == otherDecorator,]\n        }\n      }\n      \n      if (private$debug){\n        cat(\"List of outgoing edges detected: \\n\")\n        print(outgoingEdges)\n      }\n      \n      # get edges reaching node\n      incomingEdges <- edges[edges$to == node,]\n      \n      # considers node decoration\n      if (nodeDecorator == \"noblock\"){\n        incomingEdges <- incomingEdges[incomingEdges$right != \"block\",]\n      }\n      else{\n        if (nodeDecorator != \"wildcard\"){\n          incomingEdges <- incomingEdges[incomingEdges$right == nodeDecorator,]\n        }\n      }\n      \n      # considers otherNode decoration\n      if (otherDecorator == \"noblock\"){\n        incomingEdges <- incomingEdges[incomingEdges$left != \"block\",]\n      }\n      else{\n        if (otherDecorator != \"wildcard\"){\n          incomingEdges <- incomingEdges[incomingEdges$left == otherDecorator,]\n        }\n      }\n      \n      if (private$debug){\n        cat(\"List of incoming edges detected: \\n\")\n        print(incomingEdges)\n      }\n      \n      # compound the final list\n      result <- merge(outgoingEdges, incomingEdges, all=TRUE)\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- getEdgesInArgumentForNode end ---------------------\\n\")\n        cat(\"Complete list of edges: \\n\")\n        print(result)\n        cat(\"-----------------------------------------------------------------------\\n\")\n      }\n      \n      # return result\n      return(result)\n    },\n    \n    #'##############################################################\n    #' matches edges with a common node: align the edges and form a\n    #' new data structure to be used for rules applications\n    #' arguments:\n    #' @param edges list of edges to consider\n    #'##############################################################\n    matchEdgesWithCommonNode = function(edges){\n      # make cartesian product\n      prod <- merge(edges,edges,all=TRUE,by=NULL)\n      \n      # remove matches made with the same edge\n      prodf <- prod[!(prod$from.x == prod$from.y & prod$to.x == prod$to.y),]\n      \n      # select pairs with a common node\n      # e1 - e2 (to-from)\n      # e1 - e2(R) (to-to)\n      # e1(R) - e2 (from - from)\n      # e1(R) - e2(R) (from - to)\n      prodfSelected <- prodf[(prodf$to.x == prodf$from.y |\n                                prodf$to.x == prodf$to.y |\n                                prodf$from.x == prodf$from.y |\n                                prodf$from.x == prodf$to.y),]\n      \n      # return the result\n      return(prodfSelected)\n    },\n    \n    #'##############################################################\n    #' generate a data frame from the list of lists with alignment pairs. This\n    #' is an auxiliar method for rules application\n    #' arguments: \n    #' @param pairs pairs of nodes to consider (list of lists)\n    #'##############################################################\n    generateAlignmentDataFrame = function(pairs){\n      if (private$debug){\n        cat(\"\\n -------------------------- generateAlignmentDataFrame begin ---------------------\\n\")\n        cat(\"Number of pairs: \",nrow(pairs),\"\\n\")\n      }\n      \n      result <- NULL\n      # checks if there is any pair of edges with a common node\n\n      if (private$containsData(pairs)){\n         # call align edges on pairs\n         index <- seq(1:nrow(pairs))\n        \n         # generate the list with the result\n         candidatePairs <- lapply(index, private$alignEdges, df=pairs)\n         result <-data.table::rbindlist(candidatePairs)\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- generateAlignmentDataFrame end ---------------------\\n\")\n        cat(\"Final candidate pairs: \\n\")\n        if (!is.null(result)){\n          print(result)\n        }\n        else{\n          cat(\"no pairs with required conditions.....\\n\")\n        }\n      }\n      \n      # return result\n      return(result)\n    },\n    \n    #'##############################################################\n    #' method for aligning the edges with a common node between them\n    #' in order to get groups of nodes candidates for rules application\n    #' This is an auxiliar method for rules application\n    #' arguments:\n    #' @param index index of the pair of edges to consider\n    #' @param df data structure with the aligned pairs of edges\n    #'##############################################################\n    alignEdges = function(index, df){  \n      row <- df[index,]\n      \n      # get the nodes in both edges\n      nodes1 <- c(row$from.x, row$to.x)\n      nodes2 <- c(row$from.y, row$to.y)\n      \n      # gets B (coomon node)\n      bNode <- intersect(nodes1, nodes2)\n      \n      # gets the difference\n      diff <- setdiff(union(nodes1,nodes2),bNode)\n      aNode <- diff[1]\n      cNode <- diff[2]\n      \n      # assigns the decorations: it is needed to check the\n      # pattern of the alignment\n      # e1 - e2 (to-from)\n      # e1 - e2(R) (to-to)\n      # e1(R) - e2 (from - from)\n      # e1(R) - e2(R) (from - to)\n      e1Reverted <- FALSE\n      e2Reverted <- FALSE\n      if (row$to.x == bNode){\n        # first edge os ok\n        adeco <- row$left.x\n        bdeco1 <- row$right.x\n      }\n      else{\n        # first edge is reverted\n        adeco <- row$right.x\n        bdeco1 <- row$left.x\n        e1Reverted <- TRUE\n      }\n      \n      # check for the second edge\n      if (row$from.y == bNode){\n        # compounds the sequence of decorations\n        bdeco2 <- row$left.y\n        cdeco <- row$right.y\n      }\n      else{\n        # the second edge is reverted\n        bdeco2 <- row$right.y\n        cdeco <- row$left.y\n        e2Reverted <- TRUE\n      }\n      \n      # compound the info\n      return(list(anode=aNode, bnode=bNode, cnode=cNode, \n                  adeco=adeco, bdeco1=bdeco1, bdeco2=bdeco2, cdeco=cdeco,\n                  e1reverted=e1Reverted, e2reverted=e2Reverted))\n    },\n    \n    #'##############################################################\n    #' from a data frame with aligned edges, selects those matching a certain\n    #' pattern adeco- bdeco1- bdeco2 - cdeco\n    #' arguments:\n    #' @param pairs of aligned edges\n    #' @param deco1\n    #' @param deco2\n    #' @param deco3\n    #' @param deco4\n    #'##############################################################\n    selectPairPattern = function(pairs, deco1, deco2, deco3, deco4){\n      if (private$debug){\n        cat(\"\\n -------------------------- selectPairPattern begin ---------------------\\n\")\n        cat(\"Decorations to look for: \",deco1, \" - \",deco2, \" -\", deco3, \" - \", deco4, \"\\n\")\n      }\n      \n      # initializes selected with pairs\n      selected <- pairs \n      \n      # considers deco1\n      if (deco1 == \"noblock\"){\n        selected <- selected[selected$adeco != \"block\",]\n      }\n      else{\n        if (deco1 != \"wildcard\"){\n          selected <- selected[selected$adeco == deco1,]\n        }\n      }\n      \n      # considers deco2\n      if (deco2 == \"noblock\"){\n        selected <- selected[selected$bdeco1 != \"block\",]\n      }\n      else{\n        if (deco2 != \"wildcard\"){\n          selected <- selected[selected$bdeco1 == deco2,]\n        }\n      }\n      \n      # considers deco3\n      if (deco3 == \"noblock\"){\n        selected <- selected[selected$bdeco2 != \"block\",]\n      }\n      else{\n        if (deco3 != \"wildcard\"){\n          selected <- selected[selected$bdeco2 == deco3,]\n        }\n      }\n      \n      # considers deco4\n      if (deco4 == \"noblock\"){\n        selected <- selected[selected$cdeco != \"block\",]\n      }\n      else{\n        if (deco4 != \"wildcard\"){\n          selected <- selected[selected$cdeco == deco4,]\n        }\n      }\n      \n      if (private$debug){\n        cat(\"Selected pairs:  \\n\")\n        print(selected)\n        cat(\"\\n -------------------------- selectPairPattern end ---------------------\\n\")\n      }\n      \n      # return selected\n      return(selected)\n    },\n    \n    #'##############################################################\n    #' check the conditions for a pair of nodes in order to apply independence \n    #' tests on it\n    #' arguments:\n    #' @param pair pair of nodes\n    #' @param l size of separator set to consider\n    #'##############################################################\n    checkConditionsTestAnalysis = function(pair, l){\n      if (private$debug){\n        cat(\"\\n -------------------------- checkConditionTestAnalysis begin ---------------------\\n\")\n      }\n      \n      # initializes result\n      result <- list(flag=FALSE)\n      \n      # gets a and b nodes\n      anode <- pair[[1]]\n      bnode <- pair[[2]]\n      \n      # gets a adjacents\n      aAdjacents <- private$getAdjacents(anode)\n      \n      # gets b adjacents\n      bAdjacents <- private$getAdjacents(bnode)\n      \n      # check if anode belongs to bAdjacents\n      if (anode %in% bAdjacents){\n        \n        # the set of adjacents to consider will depend on the pc mode\n        # in mampc mode gets the adjacents of the adjacents set. In PC\n        # mode only considers aAdjacents\n        if (!private$pc){\n          # gets ad(ad(anodes))\n          aAdjacentsAdjacents <- private$getAdjacentsSet(aAdjacents)\n        }\n        else{\n          aAdjacentsAdjacents <- aAdjacents\n        }\n        \n        # removes a and b\n        aAdjacentsAdjacents <- aAdjacentsAdjacents[aAdjacentsAdjacents != anode &\n                                                     aAdjacentsAdjacents != bnode]\n        \n        # now checks the lenght of aAdjacents\n        if (length(aAdjacentsAdjacents) >= l){\n          result <- list(pair=list(anode,bnode), flag=TRUE, set=aAdjacentsAdjacents)\n        }\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- checkConditionTestAnalysis end ---------------------\\n\")\n        cat(\"Pair: \",pair[[1]],\" - \", pair[[2]], \" flag: \",result$flag, \n            \" candidate set: \",result$set,\"\\n\")\n        cat(\"----------------------------------------------------------------------------------\\n\")\n      }\n      \n      # return result\n      return(result)\n    },\n        \n    #'##############################################################\n    #' method for computing the adjacents for a node\n    #' arguments: \n    #' @param node node to consider\n    #'##############################################################\n    getAdjacents = function(node){\n      # return the neighbour of the node\n      return(bnlearn::nbr(private$graph,node))\n    },\n    \n    #'##############################################################\n    #' method for computing the adjacents of a set of nodes\n    #' finally append adjacents to the computed set\n    #' @param set os nodes to get adjacents \n    #'##############################################################\n    getAdjacentsSet = function(set){  \n      # get the adjacents of all the nodes in setsesion2.zip\n      setAdjacents <- unlist(lapply(set,function(x){private$getAdjacents(x)}))\n      setAdjacents <- unique(append(set,setAdjacents))\n    },\n    \n    #'##############################################################\n    #' check if there is a directed edge between the extreme nodes\n    #' arguments:\n    #' @param pairInfo info about the pair of edges to consider\n    #'##############################################################\n    checkDirectedEdgeBetweenExtremes = function(pairInfo){\n      # initializes variables\n      directedEdge <- FALSE\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- checkDirectedEdgeBetweenExtremes begin ---------------------\\n\")\n        cat(\"A: \",pairInfo$anode, \" B: \",pairInfo$bnode, \" C: \", pairInfo$cnode,\"\\n\")\n        cat(\"Pattern: \",pairInfo$adeco, \" - \", pairInfo$bdeco1, \" - \", \n            pairInfo$bdeco2, \" - \", pairInfo$cdeco,\"\\n\")\n      }\n      \n      # removes the edges with other nodes\n      involvedNodes <- list(pairInfo$anode, pairInfo$bnode, pairInfo$cnode)\n      inducedEdges <- private$getInducedSubgraph(involvedNodes)\n      \n      # checks if there is an edge between anode and cnode in inducedEdges\n      directedEdge <- private$checkEdgeInArgumentEdges(pairInfo$anode, pairInfo$cnode, inducedEdges)\n      if (private$debug){\n        cat(\"Direct edges between \",pairInfo$anode, \" and \",pairInfo$cnode,\" : \",directedEdge,\"\\n\")\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- checkDirectedEdgeBetweenExtremes end ---------------------\\n\")\n        cat(\"Directed edge: \", directedEdge,\"\\n\")\n        cat(\"------------------------------------------------------------------------------\\n\")\n      }\n      \n      # return flag\n      return(directedEdge)\n    },\n    \n    #'##############################################################\n    #' check if a pair of edges has the conditions for applying rule 2\n    #' arguments:\n    #' @param pairInfo information about the pair of edges to analyze\n    #'##############################################################\n    checkConditionForRule2 = function(pairInfo){\n      flag <- FALSE\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- checkConditionForRule2 begin ---------------------\\n\")\n        cat(\"A: \",pairInfo$anode, \" B: \",pairInfo$bnode, \" C: \", pairInfo$cnode,\"\\n\")\n        cat(\"Pattern: \",pairInfo$adeco, \" - \", pairInfo$bdeco1, \" - \", \n            pairInfo$bdeco2, \" - \", pairInfo$cdeco,\"\\n\")\n      }\n      \n      # removes the edges with other nodes\n      involvedNodes <- list(pairInfo$anode, pairInfo$bnode, pairInfo$cnode)\n      inducedEdges <- private$getInducedSubgraph(involvedNodes)\n      \n      # checks if there is an edge between anode and cnode in inducedEdges\n      directEdge <- private$checkEdgeInArgumentEdges(pairInfo$anode, pairInfo$cnode, inducedEdges)\n      if (private$debug){\n        cat(\"Direct edges between \",pairInfo$anode, \" and \",pairInfo$cnode,\" : \",directEdge,\"\\n\")\n      }\n      \n      # flag is just the opposite to directEdge\n      flag <- !directEdge\n            \n      if (private$debug){\n        cat(\"\\n -------------------------- checkConditionForRule2 end ---------------------\\n\")\n      }\n      \n      # return flag\n      return(flag)\n    },\n    \n    #'##############################################################\n    #' method for applying rule3 with a given direction given by inverted argument\n    #' arguments:\n    #' @param inverted boolean flag with the folllowing meaning\n    #'           inverted - false: direction from - to\n    #'           inverted - true: direction to - from\n    #'##############################################################\n    applyRule3WithDirection=function(inverted){\n      if (private$debug){\n        cat(\"\\n -------------------------- applyRule3WithDirection begin ---------------------\\n\")\n      }\n      \n      # flag to show if the rule was applied\n      applied <- FALSE\n      direction <- NULL\n      \n      # if direction is from-to then looks for noblock-wildcard edges\n      # in to-from direction looks for wildcard-noblock\n      if (inverted == FALSE){\n        # gets noblock-wildcard edges\n        candidateEdges <- private$edgesInfo[private$edgesInfo$left != \"block\",]\n        if (private$debug){\n          # print the list of candidate edges\n          direction <- \"Direction from - to\\n\"\n          cat(direction)\n          print(candidateEdges)\n        }\n      }\n      else{\n        # gets wildcard-noblock\n        candidateEdges <- private$edgesInfo[private$edgesInfo$right != \"block\",]\n        \n        if (private$debug){\n          # print the list of candidate edges\n          direction <- \"Direction to - from\\n\"\n          cat(direction)\n          print(candidateEdges)\n        }\n      }\n            \n      # before considering a candidate edge between A-B it is needed\n      # to check that: a) there is at least an edge with block in A\n      # side and b) there is at least an edge with block in B opposite\n      # side. This tries to avoid useless checks\n      if (private$containsData(candidateEdges)){\n        flags <- apply(candidateEdges,1,private$checkInitialConditionForRule3, inverted=inverted)\n        candidateEdges <- candidateEdges[flags,]\n        #candidateEdges <- private$checkInitialConditionForRule3(candidateEdges, inverted)\n      }\n      \n      if (private$debug){\n        cat(\"Rule 3 candidates (\",direction,\"): \",nrow(candidateEdges),\"...............\\n\")\n        print(candidateEdges)\n      }\n      \n      # proceeds to consider every candidate edge (between A and B)\n      if (private$containsData(candidateEdges)){\n        # apply rule 3 on these candidate edges\n        applied <- private$applyRule3OnCandidateEdges(candidateEdges, inverted)\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- applyRule3WithDirection end ---------------------\\n\")\n        cat(\"Applied: \",applied, \"\\n\")\n        cat(\"------------------------------------------------------------------\\n\")\n      }\n      \n      # return applied\n      return(applied)\n    },\n    \n    #'##############################################################\n    #' apply rule 3 on candidate edges\n    #' arguments:\n    #' @param candidateEdges edges to consider for applying rule 3\n    #' @param direction: boolean flag showing the direction to consider\n    #'              in the edges\n    #'##############################################################\n    applyRule3OnCandidateEdges=function(candidateEdges, direction){\n      if (private$debug){\n        cat(\"\\n -------------------------- applyRule3OnCandidateEdges begin ---------------------\\n\")\n        cat(\"Direction: \", direction)\n      }\n      \n      # flag to show if the rule was applied\n      applied <- FALSE\n      \n      # considers every pair\n      for(i in 1:nrow(candidateEdges)){\n        candidateEdge <- candidateEdges[i,]\n        \n        if(private$debug){\n          cat(\"Candidate edge for rule 3 application: \\n\")\n          print(candidateEdge)\n          cat(\"......................................................\\n\")\n        }\n        \n        # selects origin and dest according to the direction\n        if (direction == FALSE){\n          origin <- candidateEdge$from\n          dest <- candidateEdge$to\n        }\n        else{\n          origin <- candidateEdge$to\n          dest <- candidateEdge$from\n        }\n        \n        # checks if candidateEdge$to is reachable from candidateEdge$from\n        # with block - wildcard. Block must be on from side and wildcard\n        # on destination side (to). The edges are passed as argument int\n        # order to hava a recursive behaviour\n        result <- private$isReachableWithLoopAndDeco(origin, dest, \"block\", \"wildcard\", \n                                           list(origin), private$edgesInfo)\n        \n        if(private$debug){\n          cat(\"Node \",candidateEdge$to, \" reachable from \", \n              candidateEdge$from,\": \",result$flag,\"\\n\") \n        }\n        \n        # if the flag is true, then change the arc and break the loop\n        if (result$flag){\n          changed <- private$changeEdgeDecoration(origin, dest, \"block\", \"wildcard\")\n          \n          if (changed){\n            # updates applied\n            applied <- TRUE\n          \n            # adds 1 to rule3Counter\n            private$rule3Counter <- private$rule3Counter+1\n          \n            if (private$debug){\n              cat(\"............ Rule 3 applied ............\\n\")\n            }\n          \n            break\n          }\n        }\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- applyRule3OnCandidateEdges end ---------------------\\n\")\n        cat(\"Applied: \",applied, \"\\n\")\n        cat(\"------------------------------------------------------------------\\n\")\n      }\n      \n      # return applied\n      return(applied)\n    },\n    \n    #'##############################################################\n    #' checks if the edge A-B has additional edges in order\n    #' to be a candidate for rule 3 application\n    #' arguments:\n    #' @param edge edge to consider\n    #' @param inverted boolean flag \n    #'##############################################################\n    checkInitialConditionForRule3 = function(edge, inverted){\n      if (private$debug){\n        cat(\"\\n -------------------------- checkInitialConditionForRule3 begin ---------------------\\n\")\n        cat(\"Edge under analysis: \")\n        print(edge)\n        cat(\"Inverted: \",inverted,\"\\n\")\n      }\n      \n      flag <- FALSE\n      \n      # checks if the edge is a candidate for rule3 application:\n      if (inverted == FALSE){\n        # there must be an edge with block in from side\n        # there must be an edge with block in the opposite side of to side\n        edges1 <- private$edgesInfo[(private$edgesInfo$from == edge[\"from\"] &\n                                       private$edgesInfo$left == \"block\") |\n                              (private$edgesInfo$to == edge[\"from\"] &\n                                 private$edgesInfo$right == \"block\"),]\n        \n        edges2 <- private$edgesInfo[(private$edgesInfo$to == edge[\"to\"] &\n                                       private$edgesInfo$left == \"block\") |\n                              (private$edgesInfo$from == edge[\"to\"] &\n                                 private$edgesInfo$right == \"block\"),]\n        \n        if (private$debug){\n          cat(\"Number of edges with block on A \",edge[\"from\"],\" side: \",nrow(edges1),\"\\n\")\n          cat(\"Number of edges with block on B \",edge[\"to\"],\" opposite side: \",nrow(edges2),\"\\n\")\n        }\n        \n        # gives value to flag\n        if (private$containsData(edges1) & private$containsData(edges2)){\n          flag <- TRUE\n        }\n      }\n      else{\n        # checks the opposite direction\n        edges1 <- private$edgesInfo[(private$edgesInfo$from == edge[\"to\"] &\n                                       private$edgesInfo$left == \"block\") |\n                             (private$edgesInfo$to == edge[\"to\"] &\n                                private$edgesInfo$right == \"block\"),]\n        edges2 <- private$edgesInfo[(private$edgesInfo$to == edge[\"from\"] &\n                                       private$edgesInfo$left == \"block\") |\n                             (private$edgesInfo$from == edge[\"from\"] &\n                                private$edgesInfo$right == \"block\"),]\n        if (private$debug){\n          cat(\"Number of edges with block on A \",edge[\"from\"],\" side: \",nrow(edges1),\"\\n\")\n          cat(\"Number of edges with block on B \",edge[\"to\"],\" opposite side: \",nrow(edges2),\"\\n\")\n        }\n        \n        if (!is.null(edges1) & !is.null(edges2) & nrow(edges1) != 0 & nrow(edges2) != 0){\n          flag <- TRUE\n        }\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- checkInitialConditionForRule3 end ---------------------\\n\")\n        cat(\"Flag returned: \",flag,\"\\n\")\n      }\n      \n      # return flag\n      return(flag)\n    },\n    \n    #'##############################################################\n    #' check if a pair of edges has the conditions for applying rule 4\n    #' arguments:\n    #' @param quartet quartet of edges candidates to rule 4 application\n    #'##############################################################\n    checkConditionForRule4 = function(quartet){\n      flag <- FALSE\n      edge1 <- quartet$pair1\n      edge2 <- quartet$pair2\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- checkConditionForRule4 begin ---------------------\\n\")\n        cat(\"A: \",edge1$anode, \" C: \",edge1$bnode, \" B: \", edge1$cnode,\"\\n\")\n        cat(\"Pattern: \",edge1$adeco, \" - \", edge1$bdeco1, \" - \", \n            edge1$bdeco2, \" - \", edge1$cdeco,\"\\n\")\n        cat(\"A: \",edge2$anode, \" D: \",edge2$bnode, \" B: \", edge2$cnode,\"\\n\")\n        cat(\"Pattern: \",edge2$adeco, \" - \", edge2$bdeco1, \" - \", \n            edge2$bdeco2, \" - \", edge2$cdeco,\"\\n\")\n      }\n      \n      # there must be a link noblock - wildcard between edge1$anode and\n      # edge1@cnode (entre A y B)\n      directLink <- private$checkEdgeWithDecorations(edge1$anode, edge1$cnode, \"noblock\",\"wildcard\")\n      \n      # if there is such a link, keeps on checking the condition\n      if (directLink){\n        \n        # first at all get the induces subgraph\n        involvedNodes <- list(edge1$anode,edge1$bnode,edge1$cnode,edge2$bnode)\n        inducedEdges <- private$getInducedSubgraph(involvedNodes)\n        \n        # checks the presence of tha direct link between C and D (ege1$bnode and\n        # edge2$bnode)\n        cdEdge <- private$checkEdgeInArgumentEdges(edge1$bnode,edge2$bnode,private$edgesInfo)\n        \n        # keeps on testing if there are no such link\n        if (!cdEdge){\n          \n          # now check if B belongs to AC separator\n          # b should not belongs to ac separators\n          cdSeparator <- private$separators[[paste(edge1$bnode,edge2$bnode,sep=\"\")]]\n        \n          if (private$debug){\n            cat(\"Separator set between \",edge1$bnode,\" and \", edge2$bnode,\"\\n\")\n            print(cdSeparator)\n            cat(\"Edge to change: \\n\")\n            print(directLink)\n          }\n        \n          # If everything is ok return the flag\n          if (edge1$anode %in% cdSeparator){\n            flag <- TRUE\n          }\n        }\n      }\n      if (private$debug){\n        cat(\"\\n -------------------------- checkConditionForRule4 end ---------------------\\n\")\n      }\n      \n      # return flag\n      return(list(flag=flag,edge=directLink))\n    },\n    \n    #'##############################################################\n    #' check if a pair of edges has the conditions for applying step14\n    #' arguments:\n    #' @param pairInfo info about the pair of edges to consider\n    #'##############################################################\n    checkConditionForStep14 = function(pairInfo){\n      flag <- FALSE\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- checkConditionForStep14 begin ---------------------\\n\")\n        cat(\"A: \",pairInfo$anode, \" B: \",pairInfo$bnode, \" C: \", pairInfo$cnode,\"\\n\")\n        cat(\"Pattern: \",pairInfo$adeco, \" - \", pairInfo$bdeco1, \" - \", \n            pairInfo$bdeco2, \" - \", pairInfo$cdeco,\"\\n\")\n      }\n      \n      # gets involved nodes\n      involvedNodes <- list(pairInfo$anode,pairInfo$bnode,pairInfo$cnode)\n      inducedEdges <- private$getInducedSubgraph(involvedNodes)\n      \n      # checks the presence of an edge between anode and cnode\n      acnode <- private$checkEdgeInArgumentEdges(pairInfo$anode, pairInfo$cnode, inducedEdges)\n      \n      # keeps on testing if there is no such edge\n      if (acnode == FALSE){\n        # now check if B belongs to AC separator\n        # b should not belongs to ac separators\n        acSeparator <- private$separators[[paste(pairInfo$anode,pairInfo$cnode,sep=\"\")]]\n        \n        if (private$debug){\n          cat(\"Separator set between \",pairInfo$anode,\" and \", pairInfo$cnode,\"\\n\")\n          print(acSeparator)\n        }\n        \n        # If everything is ok make the change in the edges\n        if (pairInfo$bnode %in% acSeparator){\n          flag <- TRUE\n        }\n      } \n      \n      if (private$debug){\n        cat(\"\\n -------------------------- checkConditionForStep14 end ---------------------\\n\")\n      }\n      \n      # return flag\n      return(flag)\n    },\n    \n    #'##############################################################\n    #' check if a pair of edges has the conditions for applying step 15\n    #' arguments:\n    #' @param pairInfo info about the pair of edges to consider\n    #'##############################################################\n    checkConditionForStep15 = function(pairInfo){\n      flag <- FALSE\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- checkConditionForStep15 begin ---------------------\\n\")\n        cat(\"A: \",pairInfo$anode, \" B: \",pairInfo$bnode, \" C: \", pairInfo$cnode,\"\\n\")\n        cat(\"Pattern: \",pairInfo$adeco, \" - \", pairInfo$bdeco1, \" - \", \n            pairInfo$bdeco2, \" - \", pairInfo$cdeco,\"\\n\")\n      }\n            \n      # now check if there is a wildcard-wildcard edge between A nd C\n      egdes <- private$edgesInfo[pairInfo$anode == pairInfo$cnode,] \n      \n      if (private$debug){\n        cat(\"Edges between \",pairInfo$anode,\" and \", pairInfo$cnode,\" : \",nrow(edges),\"\\n\")\n      }\n      \n      # If everything is ok make the change in the edges\n      if (nrow(edges) != 0){\n        flag <- TRUE\n        \n        # change edge info: first edge remains and the second becomes to\n        # block-wildcard\n        edge <- changeEdgeInfo(pairInfo, 1, edgesInfo, \"none\", \"none\")\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- checkConditionForStep15 end ---------------------\\n\")\n      }\n      \n      # return flag\n      return(list(flag=flag, edge1=edge1, edge2=edge2))\n    },\n    \n    #'##############################################################\n    #' remove the edges in the path passed as argument. The edges\n    #' are passed as argument in order to work in a recursive mode\n    #' arguments:\n    #' @param path path to consider\n    #' @param edgesInfo data structure with edges information. This information\n    #'                  will change as long as the method goes on\n    #'##############################################################\n    removeEdgesInPath = function(path, edgesInfo){\n      # removes the edges of the path\n      for(i in 1:length(path)){\n        index1 <- i\n        index2 <- i+1\n        if (index2 > length(path)){\n          index2=1\n        }\n        nodeA <- path[[index1]]\n        nodeB <- path[[index2]]\n        \n        # gets the edge\n        edge <- private$getEdgeInArgumentForNodes(nodeA, nodeB, edgesInfo)\n        \n        # removes the edge\n        edgesInfo <- removeEdge(edge,edgesInfo)\n      }\n      \n      # return edgesInfo\n      return(edgesInfo)\n    },\n    \n    #'##############################################################\n    #' looks for an edge between nodeA and nodeB in the set of edges\n    #' passed as argument\n    #' arguments:\n    #' @param nodeA first node of interest\n    #' @param nodeB second node of interest\n    #' @param edgersInfo data structure with edges information to analyze\n    #'##############################################################\n    getEdgeInArgumentForNodes = function(nodeA, nodeB, edgesInfo){\n      if (private$debug){\n        cat(\"\\n -------------------------- getEdgeInArgumentoForNodes begin ---------------------\\n\")\n        cat(\"NodeA: \",nodeA, \"  nodeB: \",nodeB,\" \\n\")\n        cat(\"List of edges: \\n\")\n        print(edgesInfo)\n      }\n      \n      # get edges having nodeA at one side and nodeB in the other\n      edge <- edgesInfo[(edgesInfo$from == nodeA & edgesInfo$to == nodeB) |\n                          (edgesInfo$to == nodeA & edgesInfo$from == nodeB), ]\n      \n      \n      if (private$debug){\n        cat(\"\\n -------------------------- getEdgeInArgumentForNodes end ---------------------\\n\")\n        cat(\"Edge: \\n\")\n        print(edge)\n        cat(\"-----------------------------------------------------------------------\\n\")\n      }\n      \n      # make a common list with them\n      return(edge)\n    },\n    \n    #'##############################################################\n    #' gets the edges related to the list of nodes passed as argument\n    #' arguments:\n    #' @param involvedNodes nodes to use for getting the induced subgraph\n    #'##############################################################\n    getInducedSubgraph = function(involvedNodes){\n      # removes nodes with from or to not contained in involvedNodes\n      involvedEdges <- private$edgesInfo[(private$edgesInfo$from %in% involvedNodes) &\n                                           (private$edgesInfo$to %in% involvedNodes) ,]\n      \n      # return involvedEdges\n      return(involvedEdges)\n    },\n    \n    #'##############################################################\n    #' checks if there is an edge between the nodes passed as first\n    #' and second arguments and with the given decorations\n    #' arguments:\n    #' @param anode first node of interest\n    #' @param bnode second node of interest\n    #' @param aDeco decoration for first node\n    #' @param bDeco decoration for second node\n    #'##############################################################\n    checkEdgeWithDecorations = function(anode, bnode, aDeco, bDeco){\n      if (private$debug){\n        cat(\"\\n -------------------------- checkEdgeWithDecoration begin ---------------------\\n\")\n        cat(\"Looking for direct edge between \",anode,\" and\" ,bnode,\"\\n\")\n        cat(\"decoration for anode: \",aDeco,\" decoraction for bnode: \", bDeco,\"\\n\")\n      }\n      \n      flag <- FALSE\n      \n      # checks if there is such an edge\n      edges <- private$edgesInfo[(private$edgesInfo$from == anode & private$edgesInfo$to == bnode) |\n                             (private$edgesInfo$from == bnode & private$edgesInfo$to == anode),]\n      \n      if (private$debug){\n        cat(\"Edges between the nodes: \\n\")\n        print(edges)\n      }\n      \n      # selects the edge and checks the decorations\n      if (nrow(edges) != 0){\n        edge <- edges[1,]\n        \n        # checks aDeco and bDeco\n        if (edge$from == anode){\n          leftDeco <- edge$left\n          rightDeco <- edge$right\n        }\n        else{\n          leftDeco <- edge$right\n          rightDeco <- edge$left\n        }\n        \n        if (private$debug){\n          cat(\"Decoration for \",anode, \" - \", leftDeco,\"\\n\")\n          cat(\"Decoration for \",bnode, \" - \", rightDeco,\"\\n\")\n        }\n        \n        if (aDeco == \"noblock\"){\n          flag <- (leftDeco != \"block\")\n        }\n        else{\n          if (aDeco != \"wildcard\"){\n            flag <- (aDeco == leftDeco)\n          }\n        }\n        \n        # the same for bdeco\n        if (bDeco == \"noblock\"){\n          flag <- (rightDeco != \"block\")\n        }\n        else{\n          if (bDeco != \"wildcard\"){\n            flag <- (bDeco == rightDeco)\n          }\n        }\n      }\n      \n      if (private$debug){\n        cat(\"Result of check: \",flag,\"\\n\")\n        cat(\"\\n -------------------------- checkEdgeWithDecorations end ---------------------\\n\")\n      }\n      \n      # returns flag\n      return(flag)\n    },\n    \n    #'##############################################################\n    #' checks if there is an edge between the nodes passed as first\n    #' and second arguments\n    #' arguments:\n    #' @param anode first node\n    #' @param bnode second node\n    #' @param inducedEdges info about edges to analyze\n    #'##############################################################\n    checkEdgeInArgumentEdges = function(anode, cnode, inducedEdges){\n      if (private$debug){\n        cat(\"\\n -------------------------- checkEdgeInArgumentEdges begin ---------------------\\n\")\n        cat(\"Looking for direct edge between \",anode,\" and\" ,cnode,\"\\n\")\n        cat(\"Edges in induced graph\\n\")\n        print(inducedEdges)\n      }\n      \n      flag <- FALSE\n      \n      # checks if there is such an edge\n      edge <- inducedEdges[(inducedEdges$from == anode & inducedEdges$to == cnode) |\n                             (inducedEdges$from == cnode & inducedEdges$to == anode),]\n      \n      if (nrow(edge) != 0){\n        flag <- TRUE\n      }\n      \n      if (private$debug){\n        cat(\"Result of check: \",flag,\"\\n\")\n        cat(\"\\n -------------------------- checkEdgeInArgumentEdges end ---------------------\\n\")\n      }\n      \n      # returns flag\n      return(flag)\n    },\n    \n    #'##############################################################\n    #' changes the info of an edge with the information passed as first argument\n    #' the second argument shows the edge to change: 1 or 2\n    #' the information about edges is required in order to select the proper\n    #' edges and making the change on them\n    #' arguments: \n    #' @param  pairInfo info about the pair of edges containing the edge to change\n    #' @param  index 1 or 2, showing the edge in pairInfo to change\n    #' @param  edgesInfo information about edges. This info will be modified after\n    #              the change\n    #' @param  leftDeco new decoration for an extreme\n    #' @param  rightDeco new decoration for another extreme\n    #'##############################################################\n    changeEdgeInfo = function(pairInfo, index, edgesInfo, leftDeco, rightDeco){\n      if (private$debug){\n        cat(\"\\n -------------------------- changeEdgeInfo begin ---------------------\\n\")\n        cat(\"Info about pair: \\n\")\n        print(pairInfo)\n        cat(\"Edge to change: \",index,\"\\n\")\n        cat(\"New decoration to apply: \",leftDeco,\" - \", rightDeco, \"\\n\")\n      }\n      \n      # selects the nodes of the edge to change\n      reverted <- FALSE\n      if (index == 1){\n        if (pairInfo$e1reverted == FALSE){\n          from <- pairInfo$anode\n          to <- pairInfo$bnode\n        }\n        else{\n          from <- pairInfo$bnode\n          to <- pairInfo$anode\n          reverted <- TRUE\n        }\n      }\n      else{\n        # information about edge number 2\n        if (pairInfo$e2reverted == FALSE){\n          from <- pairInfo$bnode\n          to <- pairInfo$cnode\n        }\n        else{\n          from <- pairInfo$cnode\n          to <- pairInfo$bnode\n          reverted <- TRUE\n        }\n      }\n      \n      if (private$debug){\n        cat(\"In original information: from = \",from, \" - to = \",to,\" reverted: \",reverted, \"\\n\")\n      }\n      \n      # now gets the edge from edgesInfo\n      edge <- edgesInfo[(edgesInfo$from == from & edgesInfo$to == to),]\n      \n      if (private$debug){\n        cat(\"Original edge: \\n\")\n        print(edge)\n      }\n      \n      # now change the decorations according to the reversion\n      if (reverted){\n        temp <- leftDeco\n        leftDeco <- rightDeco\n        rightDeco <- temp\n      }\n      \n      # change the decorations\n      if(leftDeco != \"wildcard\"){\n        edge$left=leftDeco\n      }\n      if (rightDeco != \"wildcard\"){\n        edge$right=rightDeco\n      }\n      \n      if (private$debug){\n        cat(\"Final edge: \\n\")\n        print(edge)\n        cat(\"\\n -------------------------- changeEdgeInfo end ---------------------\\n\")\n      }\n      \n      # return the edge\n      return(edge)\n    },\n    \n    #'##############################################################\n    #' method for changing the decorations of an edge between anode\n    #' and bnode\n    #' arguments:\n    #' @param anode first node\n    #' @param bnode second node\n    #' @param anodeDeco deco for first node extreme\n    #' @param bnodedeco deco for second node extreme\n    #'##############################################################\n    changeEdgeDecoration = function(anode, bnode, anodeDeco, bnodeDeco){\n      if (private$debug){\n        cat(\"\\n -------------------------- changeEdgeDecoration begin ---------------------\\n\")\n        cat(\"Changing edge between \",anode,\" and \",bnode, \" to decos \",anodeDeco, \" - \", bnodeDeco,\"\\n\")\n      }\n      \n      changed <- FALSE\n      edge <- NULL\n      # looks for anode - bnode edge (with from - to direction)\n      edge <- private$edgesInfo[private$edgesInfo$from == anode &\n                                private$edgesInfo$to == bnode,]\n      index <- which(private$edgesInfo$from == anode & private$edgesInfo$to == bnode)\n      \n      # if this edge exists, just change the decoration\n      if(length(index) == 1){\n        if (anodeDeco != \"wildcard\"){\n          edge$left <- anodeDeco\n        }\n        if (bnodeDeco != \"wildcard\"){\n          edge$right <- bnodeDeco\n        }        \n        \n        # if working in pc mode avoid block-block edges\n        blockBlock <- FALSE\n        if (edge$left == \"block\" & edge$right == \"block\"){\n          blockBlock <- TRUE\n        }\n        \n        # change the edge if needed\n        if (!private$pc | (private$pc & !blockBlock)){\n          private$edgesInfo[index,] <- edge\n          changed <- TRUE\n        }\n      }\n      else{\n        # the edge must be in to - from orientation\n        edge <- private$edgesInfo[private$edgesInfo$to == anode &\n                                    private$edgesInfo$from == bnode,]\n        index <- which(private$edgesInfo$to == anode & private$edgesInfo$from == bnode)\n        \n        # change the edge decoration if it exists\n        if(length(index) == 1){\n          if (bnodeDeco != \"wildcard\"){\n            edge$left <- bnodeDeco\n          }\n          if(anodeDeco != \"wildcard\"){\n            edge$right <- anodeDeco\n          }\n          # if working in pc mode avoid block-block edges\n          blockBlock <- FALSE\n          if (edge$left == \"block\" & edge$right == \"block\"){\n            blockBlock <- TRUE\n          }\n          \n          # change the edge if needed\n          if (!private$pc | (private$pc & !blockBlock)){\n            private$edgesInfo[index,] <- edge\n            changed <- TRUE\n          }\n        }\n      }\n      if (private$debug){\n        cat(\"changed: \",changed,\"\\n\")\n        cat(\"\\n -------------------------- changeEdgeDecoration end ---------------------\\n\")\n      }\n      \n      # return changed\n      return(changed)\n    },\n    \n    #'##############################################################\n    #' method for checking the existance of a loop between origin and dest\n    #' without chords and using edges with a certain decoration\n    #' arguments:\n    #' @param origin first node to consider in the path\n    #' @param dest last node in the path\n    #' @param originDeco decoration for origin side in the edge starting the path\n    #' @param destDeco decoration for dest in the edge ending the path\n    #' @param path path to analyze\n    #' @param edges info about edges in the model\n    #'##############################################################\n    isReachableWithLoopAndDeco = function(origin, dest, originDeco, destDeco, path, edges){\n      if (private$debug){\n        cat(\"\\n -------------------------- isReachableWithLoopAndDeco begin ---------------------\\n\")\n        cat(\"Origin: \",origin, \" destination: \", dest, \" path: \")\n        cat(\"Origin deco: \", originDeco, \" dest deco: \", destDeco)\n        print(path)\n        cat(\"Edges to consider: \")\n        print(edges)\n      }\n      \n      # initializes an empty result\n      result <- list(\"path\"=path,\"flag\"=FALSE,\"length\"=length(path),\"loop\"=FALSE)\n      \n      # base case: dest reached and non empty path\n      if (origin == dest & length(path) != 0){\n        if (private$debug){\n          cat(\"Base case: dest and origin are the same. Path length: \",length(path),\"\\n\")\n        }\n        \n        # sets flag to true\n        result$flag <- TRUE\n        result$loop <- TRUE\n        \n        # in any case return\n        return(result)\n      }\n      \n      # if this point is reached, it is needed to keep on searching\n      # get adjacents of current node  but taking into account edges \n      # without blocks\n      candidateEdges <- private$getEdgesInArgumentForNode(origin, originDeco, destDeco, edges)\n      \n      if (private$debug){\n        cat(\"Obtained the list of adjacent to \",origin, \"\\n\")\n        cat(\"Candidate edges to consider: \",nrow(candidateEdges),\"\\n\")\n      }\n      \n      # considers every candidate\n      if (private$containsData(candidateEdges)){\n        for(i in 1:nrow(candidateEdges)){\n          # selects the candidate\n          candidate <- candidateEdges[i,]\n          \n          if (private$debug){\n            cat(\"Candidate edge under analysis: \\n\")\n            print(candidate)\n          }\n          \n          # gets the following node\n          other <- private$getFollowingNode(origin, candidate)\n          \n          if (private$debug){\n            cat(\"New destination: \",other,\"\\n\")\n          }\n          \n          # if candidate is in path there is no need to go on. In any other\n          # case go on analyzing edges\n          if (!(other %in% path)){\n            if (private$debug){\n              cat(\"Analyzing edge \", candidate$from, \" - \", candidate$to, \"\\n\")\n            }\n            \n            # adds other to path\n            path <- append(path,other)\n            \n            # removes the edge\n            edgesNew <- private$removeEdgeInArgument(candidate, edges)\n            \n            if (private$debug){\n              cat(\"Actual path from origin: \\n\")\n              print(path)\n            }\n            \n            # and checks if the other dest (the final destination, passed\n            # as argument) can be reached from destNode\n            result <- private$isReachableWithLoopAndDeco(other, dest , originDeco, destDeco, \n                                                 path, edgesNew)\n            \n            # if the result is true, no need to keep on searching\n            if(result$flag == TRUE){\n              break\n            }\n            else{\n              # removes the node under consideration from path\n              path <- path[path != other]\n              if (private$debug){\n                cat(\"Removing \",other,\" from path\\n\")\n                print(path)\n              }\n            }\n          }\n          else{\n            # the node to consider already belongs to path\n            result$flag <- FALSE\n            result$loop <- TRUE\n            result$path <- append(path,other)\n            break;\n          }\n        }\n        \n        if (private$debug){\n          cat(\"\\n -------------------------- isReachableWithLoopAndDeco end ---------------------\\n\")\n          cat(\"flag: \",result$flag,\"\\n\")\n          cat(\"loop: \",result$loop,\"\\n\")\n          cat(\"-------------------------------------------------------------------\\n\")\n        }\n      }\n      \n      # return result\n      return(result)\n    },\n    \n    #'##############################################################\n    #' gets the node at the opposite extreme of origin in edge\n    #' arguments:\n    #' @param origin origin node\n    #' @param edge edge of interest\n    #'##############################################################\n    getFollowingNode = function(origin, edge){\n      if (origin == edge$to){\n        other <- edge$from\n      }\n      else{\n        other <- edge$to\n      }\n      \n      # return other\n      return(other)\n    },\n    \n    #'##############################################################\n    #' removes the information related to a certain edge but not on the\n    #' data member but on the argument\n    #' arguments:\n    #' @param edge edge to remove\n    #' @param edgesInfo list of edges where the edge will be removed\n    #'##############################################################\n    removeEdgeInArgument = function(edge, edgesInfo){\n      # removes the used link from edgesInfo\n      ind <- which(with(edgesInfo, edgesInfo$from == edge$from & \n                          edgesInfo$to == edge$to))\n      edgesInfo <- edgesInfo[ -ind, ]\n      return(edgesInfo)\n    },\n    \n    #'##############################################################\n    #' method for getting quartets of nodes in order to apply rule 4\n    #' arguments:\n    #' @param pairs pairs of candidate pairs of edges\n    #'##############################################################\n    getQuartets = function(pairs){\n      if (private$debug){\n        cat(\"\\n -------------------------- getQuartets begin ---------------------\\n\")\n        cat(\"Number of pairs: \",nrow(pairs),\"\\n\")\n        cat(\"Pairs to consider: \\n\")\n        cat(class(pairs),\"\\n\")\n        print(pairs)\n        cat(\"\\n\")\n      }\n      candidatePairs <- NULL\n      \n      # considers every pair in restpairs\n      index <- seq(1:(nrow(pairs)-1))\n      \n      # form candidate pairs of edges: only if there is more than\n      # a edge\n      if (nrow(pairs) > 1){\n        candidatePairs <- lapply(index, private$getQuartetsForPair, df=pairs)\n        candidatePairs <- private$delete.NULLs(candidatePairs)\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- getQuartets end ---------------------\\n\")\n      }\n      return(candidatePairs)\n    },\n    \n    #'##############################################################\n    #' get quartets for a given pair of edges\n    #' arguments:\n    #' @param index edge considered as base \n    #' @param df data estructure with information to consider\n    #'##############################################################\n    getQuartetsForPair = function(index, df){\n      # selects the base pair\n      basepair <- df[index,]\n      \n      # gets the rest of elements in pairs\n      restpairs <- df[(index+1):nrow(df),]\n      \n      # considers every pair in restpairs\n      index <- seq(1:nrow(restpairs))\n      \n      # now checks if basepair and some of the pairs in restpairs\n      # can be considered for applying rule 4. It is needed a and\n      # c nodes must match between them\n      quartets <- lapply(index,function(index){\n        secondpair <- restpairs[index,]\n        if ((secondpair$anode == basepair$anode) & (secondpair$cnode == basepair$cnode)){\n          return(list(\"pair1\"=basepair,\"pair2\"=secondpair))\n        }\n      })\n      \n      # removes nulls\n      quartets[sapply(quartets, is.null)] <- NULL\n      return(quartets)\n    },\n    \n    #'##############################################################\n    #' remove the edges in the path passed as argument\n    #' arguments:\n    #' @param path path to consider\n    #' @param edgesInfo data structure with edges info\n    #'##############################################################\n    removeEdgesInArgumentInPath = function(path, edgesInfo){\n      if (private$debug){\n        cat(\"\\n -------------------------- removeEdgesInArgumentInPath begin ---------------------\\n\")\n        cat(\"Path: \\n\")\n        print(path)\n      }\n      # removes the edges of the path\n      for(i in 1:length(path)){\n        index1 <- i\n        index2 <- i+1\n        if (index2 > length(path)){\n          index2=1\n        }\n        nodeA <- path[[index1]]\n        nodeB <- path[[index2]]\n        \n        # gets the edge\n        edge <- private$getEdgeInArgumentForNodes(nodeA, nodeB, edgesInfo)\n        \n        # removes the edge\n        edgesInfo <- private$removeEdgeInArgument(edge,edgesInfo)\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- removeEdgesInArgumentInPath end ---------------------\\n\")\n      }\n      \n      # return edgesInfo\n      return(edgesInfo)\n    },\n    \n    #'##############################################################\n    #' detects duplicated nodes in a path and remove the\n    #' links related to the cycle\n    #' arguments: \n    #' @param path: path to consider\n    #' @param edges: set of edges to analyze\n    #'##############################################################\n    removeEdgesInArgumentInCycle = function(path, edges){\n      if (private$debug){\n        cat(\"\\n -------------------------- removeEdgesInArgumentInCycle begin ---------------------\\n\")\n        cat(\"Path with cycle: \\n\")\n        print(path)\n      }\n      \n      # gets the duplicated node\n      cycleNode <- path[duplicated(path)]\n      \n      if (private$debug){\n        cat(\"Node in cycle origin: \",cycleNode[[1]])\n      }\n      \n      # gets the first index containing \n      repetitions <- which(with(path,path == cycleNode[[1]]))\n      index1 <- repetitions[[1]]\n      index2 <- repetitions[[2]]\n      \n      if (private$debug){\n        cat(\"Cycle between positions \",index1,\" and \",index2)\n      }\n      \n      # gets the path from index1 to index2\n      cycle <- path[index1:index2]\n      \n      # now remove the edges in the cycle\n      edges <- private$removeEdgesInArgumentInPath(cycle,edges)\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- removeEdgesInArgumentCycle begin ---------------------\\n\")\n      }\n      \n      # return edges\n      return(edges)\n    },\n    \n    #'##############################################################\n    #' method to filter the pair of edges according to the separator\n    #' set of the extreme nodes. The boolean flag shows if the common\n    #' node must be contained on the the separator set or not\n    #' arguments:\n    #' @param pairs: pairs of edges\n    #' @param commonIncluded: boolean flag to state if the common node\n    #'                   must be contained in separators or not\n    #'##############################################################\n    filterPairsBySeparators = function(pairs, commonIncluded){\n      \n      # considers every pair in pairs\n      index <- seq(1:(nrow(pairs)-1))\n      \n      # form candidate pairs of edges: only if there is more than\n      # a edge\n      if (nrow(pairs) > 1){\n        pairs <- lapply(index, private$checkPairSeparators, df=pairs, commonIncluded=commonIncluded)\n        # remove nulls\n        pairs <- private$delete.NULLs(pairs)\n      }\n           \n      result <- NULL\n\n      if (private$containsData(pairs)){\n        result <- data.table::rbindlist(pairs) \n      }\n\n      # return the filtered pairs\n      return(result)\n    },\n    \n    #'##############################################################\n    #' checks if the node in common belongs or not to the\n    #' separator set\n    #' arguments:\n    #' @param index: index of pairs to consider\n    #' @param df: data structure with pairs of edges\n    #' @param commonIncluded: boolean flag\n    #'##############################################################\n    checkPairSeparators = function(index, df, commonIncluded){\n      pair <- df[index,]\n      # get the nodes in both edges\n      nodes1 <- c(pair$from.x, pair$to.x)\n      nodes2 <- c(pair$from.y, pair$to.y)\n      \n      # gets B (common node)\n      bNode <- intersect(nodes1, nodes2)\n     \n      # gets the nodes at the extremes\n      diff <- setdiff(union(nodes1,nodes2),bNode)\n      aNode <- diff[1]\n      cNode <- diff[2]\n      \n      # gets the separators for aNode and cNode\n      acSeparator <- private$separators[[paste(aNode,cNode,sep=\"\")]]\n      \n      # initialized FLAG to false and checks if b belongs to acSeparator\n      contained <- (bNode %in% acSeparator)\n      outputPair <- NULL\n      if ((commonIncluded & contained)  | (!commonIncluded & !contained)){\n        outputPair <- pair\n      }\n    \n      # return outputPair\n      return(outputPair)\n    },\n    \n    #'##############################################################\n    #' checks if there is an edge for two nodes with a certain pattern of\n    #' decorations:\n    #' arguments: \n    #' @param anode first node of interest\n    #' @param bnode second node of interest\n    #' @param leftDeco decoration for anode\n    #' @param rightDeco decoration for bnode\n    #'##############################################################\n    checkEdgeForNodesWithPattern = function(anode, bnode, leftDeco, rightDeco){\n      if (private$debug){\n        cat(\"\\n -------------------------- checkEdgeForNodesWithPattern begin ---------------------\\n\")\n      }\n      directedEdges <- private$getEdgesWithPatternFromTo(leftDeco, rightDeco)\n      if (!is.null(directedEdges)){\n        directedEdges <- directedEdges[directedEdges$from == anode & directedEdges$to == bnode,]\n      }\n      \n      invertedEdges <- private$getEdgesWithPatternFromTo(leftDeco,rightDeco)\n      if (!is.null(invertedEdges)){\n        invertedEdges <- invertedEdges[invertedEdges$from== bnode & invertedEdges$to == anode,]\n      }\n      \n      flag <- ((!is.null(directedEdges) & nrow(directedEdges) != 0) |\n               (!is.null(invertedEdges) & nrow(invertedEdges) != 0))\n        \n        if (private$debug){\n          cat(\"\\n -------------------------- checkEdgeForNodesWithPattern end ---------------------\\n\")\n        }\n      \n      return(flag)\n    },\n    \n    #'##############################################################\n    #' get the set of edges with a certain pattern in decorations\n    #' This method looks into the set of edges defined in the data\n    #' member edgesInfo\n    #' arguments: \n    #' @param fromDeco decoration for from side\n    #' @param toDeco  decoration for to side\n    #'##############################################################\n    getEdgesWithPatternFromTo = function(fromDeco, toDeco){\n      if (private$debug){\n        cat(\"\\n -------------------------- getEdgesWithPatternFromTo begin ---------------------\\n\")\n        cat(\"fromDeco: \",fromDeco,\" toDeco: \",toDeco,\"\\n\")\n      }\n      \n      # select edges with the goven decoration on the left side\n      if (fromDeco == \"noblock\"){\n        edges <- private$edgesInfo[private$edgesInfo$left != \"block\",]\n      }\n      else{\n        if (fromDeco != \"wildcard\"){\n          edges <- private$edgesInfo[private$edgesInfo$left == fromDeco,]\n        }\n      }\n      \n      # the same for the right decoration\n      if (toDeco == \"noblock\"){\n        edges <- edges[edges$right != \"block\",]\n      }\n      else{\n        if (toDeco != \"wildcard\"){\n          edges <- edges[edges$right == toDeco,]\n        }\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- getEdgesWithPatternFromTo end ---------------------\\n\")\n        cat(\"Returned edges: \\n\")\n        print(edges)\n      }\n      \n      # return edges\n      return(edges)\n    },\n    \n    #'##############################################################\n    #' updates the graph according to the set of edges\n    #' With his method graph data member is updated to match the\n    #' information contained into edgesInfo data member\n    #'##############################################################\n    updateGraph = function(){\n      \n      # considers every edge in edgesInfo\n      for(i in 1:nrow(private$edgesInfo)){\n        edge <- private$edgesInfo[i,]\n        if (edge$left == \"arrow\" & edge$right == \"none\"){\n          # sets the orientation in the graph\n          private$graph <- bnlearn::set.arc(private$graph,from=edge$to,to=edge$from,check.cycles=FALSE,debug=FALSE)\n        }\n        else{\n          if (edge$right == \"arrow\" & edge$left == \"none\"){\n            # sets the orientation in the graph\n            private$graph <- bnlearn::set.arc(private$graph,from=edge$from,to=edge$to,check.cycles=FALSE,debug=FALSE)\n          }\n        }\n      }\n    },\n    \n    #'##############################################################\n    #' gets vstructures with mampc perspective\n    #' arguments:\n    #' @param edges list of edges to analyze\n    #'##############################################################\n    getModelVStructuresDataFrame = function(edges){\n      if (private$debug){\n        cat(\"\\n -------------------------- getModelVStructuresDataFrame begin ---------------------\\n\")\n      }\n      \n      # creates the data frame structure for storing v-structures\n      vsdf <- data.frame(X=character(), Z=character(), \n                         Y=character(), type=numeric(), stringsAsFactors=FALSE)\n      \n      # get pairs with a common node as first step\n      pairs <- private$matchEdgesWithCommonNode(edges)\n\n      # # generate a data frame if there are pairs; in any other case\n      # NULL will be returned\n      candidatePairsdf <- private$generateAlignmentDataFrame(pairs)\n\n      # remove candidates according to moral parameter\n      if (private$moral == FALSE){\n        toRemove <- c()\n        if (!is.null(candidatePairsdf) && nrow(candidatePairsdf) != 0){\n          for(i in 1:nrow(candidatePairsdf)){\n            # selects the pair\n            pair <- candidatePairsdf[i,]\n\n            # check the condition\n            if (pair$anode %in% private$getAdjacents(pair$cnode) | \n                pair$cnode %in% private$getAdjacents(pair$anode)){\n              toRemove <- c(toRemove, i)\n            }\n          }\n        }\n\n        # remove pairs where anode and cnode are adjacents\n        if (length(toRemove) != 0){\n          candidatePairsdf <- candidatePairsdf[-toRemove,]\n        }\n      }\n      \n      # checks if there a pair and selects pairs of edges with the required pattern\n      if (private$containsData(candidatePairsdf)){\n          \n        # selects the pattern block - wildcard - wildcard - wildcard\n        vs <- private$selectPairPattern(candidatePairsdf, \"none\",\"arrow\", \n                                          \"arrow\", \"none\")\n          \n        # inserts the information into vsdf\n        vsdf <- private$insertVSInDataFrame(vsdf, vs, 1)\n          \n        # selects the pattern none - arrow - none -none\n        vs <- private$selectPairPattern(candidatePairsdf, \"none\",\"arrow\", \n                                          \"none\", \"none\")\n          \n        # inserts the information into vsdf\n        vsdf <- private$insertVSInDataFrame(vsdf, vs, 2)\n          \n        # the same for patter none - arrow - arrow - arrow\n        vs <- private$selectPairPattern(candidatePairsdf, \"none\",\"arrow\", \n                                          \"arrow\", \"arrow\")\n        \n        # inserts the information into vsdf\n        vsdf <- private$insertVSInDataFrame(vsdf, vs, 3)\n          \n        # patter none - none - arrow - none\n        vs <- private$selectPairPattern(candidatePairsdf, \"none\",\"none\", \n                                          \"arrow\", \"none\")\n          \n        # inserts the information into vsdf\n        vsdf <- private$insertVSInDataFrame(vsdf, vs, 4)\n          \n        # patter none - none - arrow - arrow\n        vs <- private$selectPairPattern(candidatePairsdf, \"none\",\"none\", \n                                          \"arrow\", \"arrow\")\n          \n        # inserts the information into vsdf\n        vsdf <- private$insertVSInDataFrame(vsdf, vs, 5)\n          \n        # patter arrow - arrow - none -none\n        vs <- private$selectPairPattern(candidatePairsdf, \"arrow\",\"arrow\", \n                                          \"none\", \"none\")\n          \n        # inserts the information into vsdf\n        vsdf <- private$insertVSInDataFrame(vsdf, vs, 6)\n          \n        # pattern arrow - arrow - arrow - none\n        vs <- private$selectPairPattern(candidatePairsdf, \"arrow\",\"arrow\", \n                                          \"arrow\", \"none\")\n          \n        # inserts the information into vsdf\n        vsdf <- private$insertVSInDataFrame(vsdf, vs, 7)\n          \n        # pattern arrow - arrow - arrow - arrow\n        vs <- private$selectPairPattern(candidatePairsdf, \"arrow\",\"arrow\", \n                                          \"arrow\", \"arrow\")\n          \n        # inserts the information into vsdf\n        vsdf <- private$insertVSInDataFrame(vsdf, vs, 8)\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- getModelVStructuresDataFrame end ---------------------\\n\")\n      }\n      \n      # return vs\n      return(vsdf)\n    },\n    \n    #'##############################################################\n    #' function to process a pair of edges checking if they compose\n    #' a v-structure\n    #' arguments:\n    #' @param pair: pair of edges to consider (as indices)\n    #' @param edges: list of edges to analyze\n    #'##############################################################\n    checkVStructure = function(pair, edges){\n      edge1 <- edges[pair[1],]\n      edge2 <- edges[pair[2],]\n      vstructure <- NULL\n      if (edge1[\"to\"] == edge2[\"to\"]){\n        vstructure <- list(\"A\"=edge1[[\"from\"]], \"B\"=edge1[[\"to\"]], \"C\"=edge2[[\"from\"]])\n      }\n      return(vstructure)\n    },\n    \n    #'##############################################################\n    #' insert vstructures stored in pairs in the data frame passed\n    #' as a first argument, avoiding repetitions\n    #' arguments:\n    #' @param vsdf: data estructure to return\n    #' @param pairs: pair of edges to consider\n    #' @param type: argument to be passes to the auxiliar method \n    #'##############################################################\n    insertVSInDataFrame = function(vsdf, pairs, type){      \n      # checks if there is something to insert\n      if (private$containsData(pairs)){\n        for(i in 1:nrow(pairs)){\n          pair <- pairs[i,]\n          vsdf <- private$checkAndInsertVS(pair, vsdf, type)\n        }\n      }\n      \n      # return vsdf\n      return(vsdf)\n    },\n    \n    #'##############################################################\n    #' check is a vstructure is contained in the data frame\n    #' arguments:\n    #' @param pair pair of edges to consider\n    #' @param vsdf data structure where information must be stored\n    #' @param type type of v-structure\n    #'##############################################################\n    checkAndInsertVS = function(pair, vsdf, type){\n      insertPosition <- nrow(vsdf)+1\n      \n      # composes the natural vstructure info\n      vs <- list(X=pair$anode, Z=pair$bnode, Y=pair$cnode, type=type)\n      vsinverted <- list(X=pair$cnode, Z=pair$bnode, Y=pair$anode, type=type)\n      # checks if present\n      if (!private$find.row(vsdf, vs) & !private$find.row(vsdf,vsinverted)){\n        vsdf[insertPosition,] <- vs\n      }\n      \n      # return df\n      return(vsdf)\n    },\n      \n    #'##############################################################\n    #' find duplicates of a row in a data frame\n    #' arguments:\n    #' @param df: data frame to consider\n    #' @param row: row to consider\n    #'##############################################################\n    find.row = function(df, row){\n      if (private$debug){\n        cat(\"\\n -------------------------- find.row begin ---------------------\\n\")\n        cat(\"row to look for: \\n\")\n        print(row)\n        cat(\"------------------------------------------------------------------------------\")\n      }\n      \n      # initializes found to FALSE\n      found <- FALSE\n      \n      if (nrow(df) != 0){\n        matched <- df[(df$X == row$X & df$Y == row$Y & df$Z == row$Z), ]\n        found <- (nrow(matched) != 0)\n      }\n      \n      if (private$debug){\n        cat(\"\\n -------------------------- find.row end ---------------------\\n\")\n        cat(\"Returning \", found, \"\\n\")\n        cat(\"------------------------------------------------------------------------------\")\n      }\n      \n      return(found)\n    },\n    \n    #'##############################################################\n    #' compares vstructures passed as argument\n    #' arguments: \n    #' @param targetVsdf: info about true v-structures\n    #' @param currentVsdf: info about learnt v-structures\n    #'##############################################################\n    compareVStructures = function(targetVsdf, currentVsdf){\n      if (private$debug){\n        cat(\"\\n -------------------------- compareVStructures begin ---------------------\\n\")\n        cat(\"Edges in current structure: \\n\")\n        print(private$edgesInfo)\n        cat(\"V-structures in target structure: \\n\")\n        print(targetVsdf)\n        cat(\"V-structures in current structure\\n\")\n        print(currentVsdf)\n        cat(\"------------------------------------------------------------------------------\")\n      }\n      # initializes variables\n      # tp: present in both sets\n      # fp: present in current and missing in target\n      # fn: present in target and missing in current\n      tp <- 0\n      fp <- 0\n      fn <- 0\n      \n      # considers structures in targetVsdf and check if present in currentVsdf\n      if (private$debug){\n        cat(\"Comparing target against current: \\n\")\n      }\n      \n      if(nrow(targetVsdf) != 0){\n        for(i in 1:nrow(targetVsdf)){\n          vs <- targetVsdf[i,]\n          vsInverted <- list(X=vs$Y,Z=vs$Z,Y=vs$X,type=vs$type)\n        \n          if (private$debug){\n            cat(\"Checking : \\n\")\n            print(vs)\n            cat(\" and \\n\")\n            print(vsInverted)\n          }\n          if (private$find.row(currentVsdf,vs)){\n            tp <- tp+1\n            if (private$debug){\n              cat(\"Match in normal direction: \",tp,\"\\n\")\n            }\n          }\n          else{\n            # checks the opposite direction\n            if (private$find.row(currentVsdf,vsInverted)){\n              tp <- tp+1\n              if (private$debug){\n                cat(\"Match in opposite direction: \",tp,\"\\n\")\n              }\n            }\n            else{\n              fn <- fn+1\n              if (private$debug){\n                cat(\"Not-found v-structure: \",fn,\"\\n\")\n              }\n            }\n          }\n        }\n      }\n      \n      if (private$debug){\n        cat(\"\\nComparing current against target: \\n\")\n      }\n      \n      # considers structures in currentVsdf and check if missing in targetVsdf\n      if (nrow(currentVsdf) != 0){\n        for(i in 1:nrow(currentVsdf)){\n          vs <- currentVsdf[i,]\n          vsInverted <- list(X=vs$Y,Z=vs$Z,Y=vs$X,type=vs$type)\n          if (!private$find.row(targetVsdf,vs) & !private$find.row(targetVsdf,vsInverted)){\n            fp <- fp+1\n            if (private$debug){\n              cat(\"\\nV-structure not found on target structure: \",fn,\"\\n\")\n            }\n          }\n        }\n      }\n      \n      # now computed the corresponding measures\n      if (private$debug){\n         cat(\"COUNTERS: tp: \",tp,\" fn: \", fn, \" fp: \",fp,\"\\n\")\n      }\n      recall <- tp/(tp+fn)\n      precision <- tp/(tp+fp)\n      \n      if (private$debug){\n        cat(\"Recall: \",recall,\"\\n\");\n        cat(\"Precision: \", precision,\"\\n\")\n        cat(\"\\n -------------------------- compareVStructures end ---------------------\\n\")\n      }\n      \n      # return the results\n      return(list(recall=recall,precision=precision))\n    },\n    \n    #'##############################################################\n    #' delete null values from a list\n    #' arguments:\n    #' @param x.list: list to consider\n    #'##############################################################\n    delete.NULLs  =  function(x.list){   # delele null/empty entries in a list\n      x.list[unlist(lapply(x.list, length) != 0)]\n    },\n\n    #'##############################################################\n    #' checks the data is not null and contains data\n    #' arguments:\n    #' @param data: data structure to consider\n    #'##############################################################\n    containsData = function(data){\n      flag <- FALSE\n      \n      if (!is.null(data)){\n        flag <- TRUE\n        if((class(data)[1] == \"list\")){\n          flag <- (length(data) != 0)\n        }\n        else{\n          flag <- (nrow(data) != 0)\n        }\n      }\n      return(flag)\n    }\n  )\n)\n\n#'##############################################################\n#' easy constructor of MampcSearch class. \n#' NOTE: Observe default values for some parameters\n#'##############################################################\nbuildObject <- function(net, data, moral=TRUE, pc=FALSE, alpha=0.05, edges=NULL, debug=FALSE){\n  MAMPCGSearch$new(net, data, moral, pc, alpha, edges, debug)\n}\n\n",
    "created" : 1445328069172.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "962901172",
    "id" : "1B7130FA",
    "lastKnownWriteTime" : 1445353477,
    "path" : "~/desarrollo/jmpenna/aprendizaje/versionComentada/mampcg/R/MAMPCGSearch.R",
    "project_path" : "R/MAMPCGSearch.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : true,
    "type" : "r_source"
}